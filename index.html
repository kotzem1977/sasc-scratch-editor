<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (fiber-scan+observer)</title>
  <link rel="icon" href="./favicon.ico"/>

  <script>
/* --- REPLACE the helpers & actions below in your existing tools block --- */

/* fetch the bytes once; keep both blob and (if SVG) text */
async function fetchAsset(md5ext){
  const ext = md5ext.split('.').pop().toLowerCase();
  const isSVG = ext === 'svg';
  const base = location.pathname.replace(/\/[^/]*$/,'/').replace(/\/$/,'');
  const local = base + '/static/assets/' + md5ext;

  async function read(res){
    const buf = await res.arrayBuffer();
    const blob = new Blob([buf], {type: isSVG ? 'image/svg+xml' :
                                         ext==='png' ? 'image/png' :
                                         (ext==='jpg'||ext==='jpeg') ? 'image/jpeg' :
                                         ext==='gif' ? 'image/gif' :
                                         ext==='wav' ? 'audio/wav' :
                                         ext==='mp3' ? 'audio/mp3' :
                                         'application/octet-stream'});
    const text = isSVG ? await (new Response(blob)).text() : null;
    return {buf, blob, text, ext, isSVG};
  }

  try {
    const rLocal = await fetch(local, {cache:'no-store'});
    if (rLocal.ok) return read(rLocal);
  } catch (_) {}

  const cdn = 'https://assets.scratch.mit.edu/internalapi/asset/'+md5ext+'/get/';
  const rCdn = await fetch(cdn, {cache:'no-store'});
  if (!rCdn.ok) throw new Error('CDN '+rCdn.status);
  return read(rCdn);
}

/* costume metadata helper */
function costumeFromMd5(name, md5ext){
  const isSVG = /\.svg$/i.test(md5ext);
  const assetId = md5ext.slice(0,32);
  return {
    name: name || ('Costume '+md5ext.slice(0,6)),
    assetId,
    md5ext,
    dataFormat: isSVG ? 'svg' : 'png',
    rotationCenterX: 240,
    rotationCenterY: 180
  };
}

/* attach image data to VM storage + renderer, and select it */
async function applyCostumeToTarget(vm, target, md5ext, asset){
  const storage = vm.runtime?.storage;
  if (!storage) throw new Error('No VM storage');

  const id = md5ext.slice(0,32);
  const type = asset.isSVG ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
  storage.createAsset(type, asset.ext, new Uint8Array(asset.buf), id);

  // ensure costume entry exists in sprite model
  const costume = costumeFromMd5(null, md5ext);
  target.sprite.costumes = [costume];        // replace any existing list for “clean” swap
  target.setCostume(0);

  // create a skin and attach it to the drawable so the Stage/Pane actually shows it
  if (vm.renderer && target.drawableID != null) {
    if (asset.isSVG && vm.renderer.createSVGSkin) {
      const svgText = asset.text ?? await (new Response(asset.blob)).text();
      const skinId = vm.renderer.createSVGSkin(svgText);
      vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
    } else if (!asset.isSVG && vm.renderer.createBitmapSkin) {
      const bmp = await createImageBitmap(asset.blob);
      const skinId = vm.renderer.createBitmapSkin(bmp, 1);
      vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
    }
  }

  try { vm.runtime.emit('PROJECT_CHANGED'); } catch(_) {}
}

/* ✅ Sprite creation that really swaps in the Apple SVG */
async function addSpriteFromCostume(name, md5ext){
  const vm = window.vm || await bindVM(6000);
  if (!vm?.runtime) throw new Error('vm missing');

  // Find any existing sprite to duplicate (Sprite1 etc.)
  const sprites = (vm.runtime.targets||[]).filter(t=>!t.isStage);
  if (!sprites.length) throw new Error('No base sprite to duplicate (Sprite1 missing?)');
  const baseId = sprites[0].id;

  const newId = await vm.duplicateSprite(baseId).catch(()=>null);
  if (!newId) throw new Error('duplicateSprite failed');

  const tgt = (vm.runtime.targets||[]).find(t=>t.id===newId);
  if (!tgt) throw new Error('New sprite target not found');

  try { await vm.renameSprite(newId, name||'New Sprite'); } catch(_) {
    if (tgt.sprite) tgt.sprite.name = name||'New Sprite';
  }

  const asset = await fetchAsset(md5ext);
  await applyCostumeToTarget(vm, tgt, md5ext, asset);

  __sascTag('tools','sprite created: '+(name||md5ext));
}

/* ✅ Costume to selected, with real storage+skin */
async function addCostumeToSelected(name, md5ext){
  const vm = window.vm || await bindVM(6000), GUI = window.GUI;
  if (!vm?.runtime) throw new Error('vm missing');
  const t = vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
  if (!t) throw new Error('No editing target');

  // Try GUI helper first (some builds support it)
  const asset = await fetchAsset(md5ext);
  const isSVG = asset.isSVG;
  if (GUI?.handleCostumeUpload) {
    try { await GUI.handleCostumeUpload(asset.blob, isSVG?'image/svg+xml':'image/png', t.id);
          __sascTag('costume','success via GUI.handleCostumeUpload'); return; }
    catch(e){ __sascTag('costume','GUI helper failed: '+(e&&e.message||e)); }
  }

  // Manual, guaranteed path:
  await applyCostumeToTarget(vm, t, md5ext, asset);
  __sascTag('costume','success via manual injection');
}

/* ✅ Backdrop manual fallback now also creates a skin */
async function addBackdropSmart(name, md5ext){
  const vm = window.vm || await bindVM(6000), GUI = window.GUI;
  if (!vm?.runtime) throw new Error('vm missing');
  const asset = await fetchAsset(md5ext);
  const isSVG = asset.isSVG;

  if (GUI?.handleBackdropUpload) {
    try { await GUI.handleBackdropUpload(asset.blob, isSVG?'image/svg+xml':'image/png');
          __sascTag('backdrop','success via GUI.handleBackdropUpload'); return; }
    catch(e){ __sascTag('backdrop','GUI helper failed: '+(e&&e.message||e)); }
  }
  if (typeof vm.addBackdrop === 'function') {
    try { await vm.addBackdrop(md5ext, costumeFromMd5(name, md5ext));
          __sascTag('backdrop','success via vm.addBackdrop'); return; }
    catch(e){ __sascTag('backdrop','vm.addBackdrop failed: '+(e&&e.message||e)); }
  }

  // Manual Stage injection with skin
  const stage = vm.runtime.getTargetForStage?.();
  if (!stage) throw new Error('No stage target');
  await applyCostumeToTarget(vm, stage, md5ext, asset);
  __sascTag('backdrop','success via manual stage injection');
}
</script>
</body>
</html>
