<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (fiber-scan+observer)</title>
  <link rel="icon" href="./favicon.ico"/>

  <script>
(function(){
  /* ---------- VM binding (same as before, shortened) ---------- */
  function fiberKeyOf(n){ if(!n) return null; for(const k in n){ if(k.startsWith('__reactFiber$')||k.startsWith('__reactInternalInstance$')) return k; } return null; }
  function findAnyFiberNode(root){ if(!root) return null; const q=[root]; while(q.length){ const n=q.shift(); if(fiberKeyOf(n)) return n; if(n.shadowRoot) q.push(n.shadowRoot); if(n.childNodes) for(const c of n.childNodes) q.push(c); } return null; }
  function getReactFiberFromDom(node){ const k=fiberKeyOf(node); return k?node[k]:null; }
  function* walkFibers(root){ if(!root) return; const seen=new Set(), stack=[root]; while(stack.length){ const f=stack.pop(); if(!f||seen.has(f)) continue; seen.add(f); yield f; if(f.child) stack.push(f.child); if(f.sibling) stack.push(f.sibling); if(f.return&&!seen.has(f.return)) stack.push(f.return); } }
  function tryExtractStoreFromFiber(f){ try{ const n=f.stateNode; if(n?.store?.getState) return n.store; if(n?.props?.store?.getState) return n.props.store; }catch(_){ } return null; }
  function vmFromStore(store){ try{ const st=store.getState?.(); if(st?.vm?.runtime) return st.vm; if(st?.scratchGui?.vm?.runtime) return st.scratchGui.vm; if(st?.scratch?.vm?.runtime) return st.scratch.vm; }catch(_){ } return null; }

  async function bindVM(timeoutMs=15000){
    const t0=Date.now(), app=document.getElementById('app');
    function tryOnce(){
      const GUI=window.GUI||{}; const direct=window.vm||GUI.vm;
      if(direct?.runtime){ window.vm=direct; __sascTag('VM','ready (direct)'); return direct; }
      const host=findAnyFiberNode(app); if(!host) return null;
      const root=getReactFiberFromDom(host); if(!root) return null;
      for(const f of walkFibers(root)){
        // look for a store first (it often delivers VM soon after mount)
        const store=tryExtractStoreFromFiber(f);
        if(store){
          try{ const unsub=store.subscribe(()=>{ const v=vmFromStore(store); if(v?.runtime && !window.vm){ window.vm=v; __sascTag('VM','ready (store subscribe)'); try{unsub();}catch(_){}}}); }catch(_){}
          const vNow=vmFromStore(store); if(vNow?.runtime){ window.vm=vNow; __sascTag('VM','ready (store immediate)'); return vNow; }
        }
        // direct VM-like object in props/state
        try{
          const props=f.memoizedProps||f.pendingProps||(f.stateNode&&f.stateNode.props);
          const state=f.memoizedState||(f.stateNode&&f.stateNode.state);
          for(const c of [props,state,f.stateNode,f]){
            if(!c || typeof c!=='object') continue;
            for(const k in c){ const v=c[k]; if(v && typeof v==='object' && v.runtime && v.runtime.targets){ window.vm=v; __sascTag('VM','ready (fiber props/state)'); return v; } }
          }
        }catch(_){}
      }
      return null;
    }
    while(Date.now()-t0<timeoutMs){
      const v=tryOnce(); if(v) return v;
      await new Promise(r=>setTimeout(r,250)); __sascLog('still waiting for VM…');
    }
    __sascLog('rebind: VM not found after fiber scan'); return null;
  }

  /* ---------- asset helpers ---------- */
  function parseMd5ext(s){ const m=String(s||'').match(/^([a-f0-9]{32})\.(\w+)$/i); return m?{id:m[1],ext:m[2].toLowerCase()}:null; }
  function mimeFromExt(ext){
    if(ext==='svg')return'image/svg+xml'; if(ext==='png')return'image/png';
    if(ext==='jpg'||ext==='jpeg')return'image/jpeg'; if(ext==='gif')return'image/gif';
    if(ext==='wav')return'audio/wav'; if(ext==='mp3')return'audio/mp3';
    return'application/octet-stream';
  }
  async function fetchAsset(md5ext){
    const base=location.pathname.replace(/\/[^/]*$/,'/').replace(/\/$/,'');
    const local=base+'/static/assets/'+md5ext;
    try{ const r=await fetch(local,{cache:'no-store'}); if(r.ok){ const buf=await r.arrayBuffer(); return {buf,blob:new Blob([buf],{type:mimeFromExt(md5ext.split('.').pop())})}; } }catch(_){}
    const cdn='https://assets.scratch.mit.edu/internalapi/asset/'+md5ext+'/get/';
    const r2=await fetch(cdn,{cache:'no-store'}); if(!r2.ok) throw new Error('CDN '+r2.status);
    const buf=await r2.arrayBuffer(); return {buf,blob:new Blob([buf],{type:mimeFromExt(md5ext.split('.').pop())})};
  }
  function costumeFromMd5(name, md5ext){
    const isSVG=/\.svg$/i.test(md5ext);
    const p=parseMd5ext(md5ext)||{id:'',ext:isSVG?'svg':'png'};
    return { name: name||('Costume '+md5ext.slice(0,6)), assetId:p.id, md5ext, dataFormat:isSVG?'svg':'png', rotationCenterX:240, rotationCenterY:180 };
  }

  /* ---------- new sprite via duplicate + costume swap (works with SVG/PNG) ---------- */
  async function addSpriteFromCostume(name, md5ext){
    const vm=window.vm || await bindVM(6000);
    if(!vm?.runtime) throw new Error('vm missing');

    // Find any existing sprite (non-stage) to duplicate
    const sprites=(vm.runtime.targets||[]).filter(t=>!t.isStage);
    if(!sprites.length) throw new Error('No base sprite to duplicate (Sprite1 missing?)');
    const baseId=sprites[0].id;

    // Duplicate it to create a brand new sprite
    const newId = await vm.duplicateSprite(baseId).catch(()=>null);
    if(!newId) throw new Error('duplicateSprite failed');

    // Get the new target and swap in the costume
    const tgt = (vm.runtime.targets||[]).find(t=>t.id===newId);
    if(!tgt) throw new Error('New sprite target not found');

    // Rename
    try{ await vm.renameSprite(newId, name||'New Sprite'); }catch(_){ if(tgt.sprite) tgt.sprite.name = name||'New Sprite'; }

    // Clear existing costumes and inject our one
    const cos = costumeFromMd5(name||'Sprite', md5ext);
    tgt.sprite.costumes = [cos];
    tgt.setCostume(0);

    // Nudge renderer / project change
    try{ vm.runtime.emit('PROJECT_CHANGED'); }catch(_){}
    __sascTag('tools','sprite created from costume: '+(name||md5ext));
  }

  /* ---------- backdrop (Stage) ---------- */
  async function addBackdropSmart(name, md5ext){
    const vm=window.vm || await bindVM(6000), GUI=window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const asset=await fetchAsset(md5ext);
    const isSVG=/\.svg$/i.test(md5ext);
    // Prefer GUI helper when present
    if(GUI?.handleBackdropUpload){
      try{ await GUI.handleBackdropUpload(asset.blob, isSVG?'image/svg+xml':'image/png'); __sascTag('backdrop','success via GUI.handleBackdropUpload'); return; }
      catch(e){ __sascTag('backdrop','GUI.handleBackdropUpload failed: '+(e&&e.message||e)); }
    }
    // VM path
    if(typeof vm.addBackdrop==='function'){
      try{
        const costume=costumeFromMd5(name||('Backdrop '+md5ext.slice(0,6)), md5ext);
        await vm.addBackdrop(md5ext,costume); __sascTag('backdrop','success via vm.addBackdrop'); return;
      }catch(e){ __sascTag('backdrop','vm.addBackdrop failed: '+(e&&e.message||e)); }
    }
    // Manual stage injection
    const stage = vm.runtime.getTargetForStage?.();
    if(!stage) throw new Error('No stage target');
    const costume=costumeFromMd5(name||('Backdrop '+md5ext.slice(0,6)), md5ext);
    stage.sprite.costumes.push(costume);
    stage.setCostume(stage.sprite.costumes.length-1);
    try{ vm.runtime.emit('PROJECT_CHANGED'); }catch(_){}
    __sascTag('backdrop','success via manual stage injection');
  }

  /* ---------- costume to selected ---------- */
  async function addCostumeToSelected(name, md5ext){
    const vm=window.vm || await bindVM(6000), GUI=window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const t = vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
    if(!t) throw new Error('No editing target');
    const asset=await fetchAsset(md5ext);
    const isSVG=/\.svg$/i.test(md5ext);

    if(GUI?.handleCostumeUpload){
      try{ await GUI.handleCostumeUpload(asset.blob, isSVG?'image/svg+xml':'image/png', t.id); __sascTag('costume','success via GUI.handleCostumeUpload'); return; }
      catch(e){ __sascTag('costume','GUI.handleCostumeUpload failed: '+(e&&e.message||e)); }
    }
    if(typeof vm.addCostume==='function'){
      try{ await vm.addCostume(costumeFromMd5(name, md5ext), t.id); __sascTag('costume','success via vm.addCostume'); return; }
      catch(e){ __sascTag('costume','vm.addCostume failed: '+(e&&e.message||e)); }
    }
    // Manual
    t.sprite.costumes.push(costumeFromMd5(name, md5ext));
    t.setCostume(t.sprite.costumes.length-1);
    try{ vm.runtime.emit('PROJECT_CHANGED'); }catch(_){}
    __sascTag('costume','success via manual injection');
  }

  /* ---------- sound to selected ---------- */
  async function addSoundToSelected(name, md5ext){
    const vm=window.vm || await bindVM(6000), GUI=window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const t = vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
    if(!t) throw new Error('No editing target');

    const asset=await fetchAsset(md5ext);
    if(GUI?.handleSoundUpload){
      try{ await GUI.handleSoundUpload(asset.blob, t.id); __sascTag('sound','success via GUI.handleSoundUpload'); return; }
      catch(e){ __sascTag('sound','GUI.handleSoundUpload failed: '+(e&&e.message||e)); }
    }
    if(typeof vm.addSound==='function'){
      try{
        const p=parseMd5ext(md5ext)||{id:'',ext:'wav'};
        const snd={ name:name||('Sound '+md5ext.slice(0,6)), assetId:p.id, md5ext, dataFormat:p.ext, format:'', rate:44100, sampleCount:0 };
        await vm.addSound(md5ext, snd, t.id); __sascTag('sound','success via vm.addSound'); return;
      }catch(e){ __sascTag('sound','vm.addSound failed: '+(e&&e.message||e)); }
    }
    throw new Error('No sound upload path available in this build');
  }

  /* ---------- wire buttons ---------- */
  document.getElementById('btn-bind')?.addEventListener('click',()=>bindVM(10000));
  document.getElementById('btn-targets')?.addEventListener('click',()=>{
    const vm=window.vm; if(!vm?.runtime) return __sascTag('targets','VM not ready');
    const ts=vm.runtime.targets||[]; __sascLog('[targets] '+ts.length+' targets');
    ts.forEach(t=>__sascLog('- ['+(t.isStage?'STAGE':'SPRITE')+'] '+(t.getName?t.getName():t.sprite?.name||'(?)')));
  });
  document.getElementById('btn-apple')?.addEventListener('click',()=>{
    // Apple costume SVG
    addSpriteFromCostume('Apple','3826a4091a33e4d26f87a2fac7cf796b.svg')
      .catch(e=>__sascTag('tools','apple failed: '+(e&&e.message||e)));
  });
  document.getElementById('btn-backdrop')?.addEventListener('click',()=>{
    const md5ext=prompt('Backdrop md5.ext (svg/png):','e7c147730f19d284bcd7b3f00af19bb6.svg'); if(!md5ext) return;
    addBackdropSmart('Backdrop '+md5ext.slice(0,6), md5ext.trim())
      .catch(e=>__sascTag('tools','add backdrop failed: '+(e&&e.message||e)));
  });
  document.getElementById('btn-costume')?.addEventListener('click',()=>{
    const md5ext=prompt('Costume md5.ext (svg/png):','3826a4091a33e4d26f87a2fac7cf796b.svg'); if(!md5ext) return;
    addCostumeToSelected('Costume '+md5ext.slice(0,6), md5ext.trim())
      .catch(e=>__sascTag('tools','add costume failed: '+(e&&e.message||e)));
  });
  document.getElementById('btn-sound')?.addEventListener('click',()=>{
    const md5ext=prompt('Sound md5.ext (wav/mp3):','0b1e3033140d094563248e61de4039e5.wav'); if(!md5ext) return;
    addSoundToSelected('Sound '+md5ext.slice(0,6), md5ext.trim())
      .catch(e=>__sascTag('tools','add sound failed: '+(e&&e.message||e)));
  });

  // auto-bind after GUI mount
  bindVM(20000);
})();
</script>

</body>
</html>
