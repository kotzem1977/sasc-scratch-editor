<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (fiber-scan+observer)</title>
  <link rel="icon" href="./favicon.ico"/>

  <style>
    html,body,#app{height:100%;margin:0}
    #app{display:flex;align-items:stretch;justify-content:stretch;background:#0b1120}

    /* SASC console — light by default for readability */
    #sasc-console{position:fixed;left:10px;bottom:10px;width:560px;max-height:60vh;background:#fff;color:#111;
      font:12px/1.35 ui-monospace,Consolas,monospace;border:1px solid #89a;border-radius:8px;z-index:99999}
    #sasc-console:not([data-theme="light"]){background:#0b0e;color:#0ff;border-color:#044}
    #sasc-console header{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:6px 8px;background:#f4f7ff;border-bottom:1px solid #89a;border-radius:8px 8px 0 0}
    #sasc-console:not([data-theme="light"]) header{background:#022;border-bottom-color:#044}
    #sasc-console header strong{margin-right:auto}
    #sasc-console pre{margin:0;padding:6px 8px;white-space:pre-wrap;overflow:auto;max-height:calc(60vh - 104px);user-select:text}
    #sasc-console button{all:unset;cursor:pointer;color:inherit;padding:3px 7px;border:1px solid currentColor;border-radius:6px}
    #sasc-console .btnrow button{margin-left:4px}

    /* Minimal layout shim so GUI renders on custom builds */
    [class*="gui-body"]{display:flex;min-height:100vh}
    [class*="stage-wrapper"]{position:relative;z-index:0;flex:0 0 auto}
    [class*="stage-header"]{position:relative;z-index:2}
    [class*="green-flag"],[class*="stop-all"]{position:relative;z-index:3}
    [class*="blockly"],[class*="blocks"]{min-width:280px;flex:1 1 50%}
    [class*="target-pane"]{min-width:240px;flex:0 0 240px}
    [class*="react-modal"],[class*="modal-content"]{z-index:9999;position:relative}
    canvas{cursor:default}
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- SASC console -->
  <div id="sasc-console" data-theme="light">
    <header>
      <strong>SASC</strong>
      <button id="btn-clear">Clear</button>
      <button id="btn-contrast">Contrast</button>
      <button id="btn-copy">Copy Log</button>
      <button id="btn-save">Save Log</button>
      <span class="btnrow">
        <button id="btn-bind">Bind VM</button>
        <button id="btn-targets">List Targets</button>
      </span>
      <span class="btnrow">
        <!-- Open GUI libraries (same as Scratch’s own buttons) -->
        <button id="btn-lib-sprite">Sprite Library</button>
        <button id="btn-lib-backdrop">Backdrop Library</button>
        <button id="btn-lib-costume">Costume Library</button>
        <button id="btn-lib-sound">Sound Library</button>
      </span>
      <span class="btnrow">
        <!-- Generic: add by md5 / by file -->
        <button id="btn-sprite-b">Add Sprite by md5</button>
        <button id="btn-sprite-c">Add Sprite from file</button>
        <button id="btn-bg-b">Backdrop by md5</button>
        <button id="btn-bg-c">Backdrop from file</button>
        <button id="btn-snd-b">Sound by md5</button>
        <button id="btn-snd-c">Sound from file</button>
      </span>
      <span class="btnrow">
        <!-- Diagnostic apples -->
        <button id="btn-apple-a">Apple A</button>
        <button id="btn-apple-b">Apple B</button>
        <button id="btn-apple-c">Apple C</button>
      </span>
    </header>
    <pre>SASC clear
</pre>
  </div>

  <!-- hidden file inputs for C-paths -->
  <input id="file-image" type="file" accept=".svg,.png,.jpg,.jpeg,.gif,image/*" style="display:none"/>
  <input id="file-sound" type="file" accept=".wav,.mp3,audio/*" style="display:none"/>

  <!-- Console wiring -->
  <script>
    (function(){
      const pre=document.querySelector('#sasc-console pre');
      const box=document.getElementById('sasc-console');
      const out=(tag,msg)=>{ const line=(tag?(`[${tag}] `):'')+msg; try{pre.textContent+=line+'\\n'; pre.scrollTop=pre.scrollHeight;}catch(_){} console.log(line); };
      window.__sascLog=(m)=>out('',m);
      window.__sascTag=(t,m)=>out(t,m);

      document.getElementById('btn-clear').onclick=()=>{ pre.textContent='SASC clear\\n'; };
      document.getElementById('btn-contrast').onclick=()=>{ box.toggleAttribute('data-theme','light'); };
      document.getElementById('btn-copy').onclick=async()=>{
        try{ await navigator.clipboard.writeText(pre.textContent); out('SASC','log copied to clipboard'); }
        catch(_){
          const r=document.createRange(); r.selectNodeContents(pre);
          const s=window.getSelection(); s.removeAllRanges(); s.addRange(r);
          const ok=document.execCommand('copy'); s.removeAllRanges();
          out('SASC', ok?'log copied (fallback)':'copy failed');
        }
      };
      document.getElementById('btn-save').onclick=()=>{
        const blob=new Blob([pre.textContent],{type:'text/plain'});
        const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sasc-log.txt'; a.click();
        setTimeout(()=>URL.revokeObjectURL(a.href),1000);
        out('SASC','log saved as sasc-log.txt');
      };
      window.addEventListener('unhandledrejection',e=>out('unhandledrejection',(e.reason&&(e.reason.stack||e.reason))));
    })();
  </script>

  <!-- React UMDs -->
  <script src="https://unpkg.com/react@16.14.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@16.14.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
  <script>
    (function(){
      if(window.React && !window.react){ window.react=window.React; __sascTag('SASC','react alias set');}
      if(window.ReactDOM && !window['react-dom']){ window['react-dom']=window.ReactDOM; __sascTag('SASC','react-dom alias set');}
      if(window.Redux && !window.redux){ window.redux=window.Redux; __sascTag('SASC','redux alias set');}
    })();
  </script>

  <!-- Local-first hooks for internalapi assets (kept, but gentle) -->
  <script>
    (function(){
      const base=location.pathname.replace(/\\/[^/]*$/,'/'); const repoRoot=base.replace(/\\/$/,'');
      const toLocal=u=>{ const m=u&&u.match(/internalapi\\/asset\\/([a-f0-9]{32}\\.(?:sprite3|json|svg|png|gif|jpg|wav|mp3))\\/get\\/?/i); return m?(repoRoot+'/static/assets/'+m[1]):null; };
      const realFetch=window.fetch;
      window.fetch=async function(i,init){
        const url=(typeof i==='string')?i:(i&&i.url);
        const local=toLocal(url);
        if(local){
          try{
            const r=await realFetch(local,init);
            if(r&&r.ok) return r;
          }catch(_){}
          // fall through to original URL if local fails
        }
        return realFetch.apply(this,arguments);
      };
      const XO=XMLHttpRequest;
      window.XMLHttpRequest=function(){
        const x=new XO(); const _open=x.open; let original=null,method='GET';
        x.open=function(m,u){
          method=m; original=u; const local=(typeof u==='string')?toLocal(u):null;
          if(local){
            _open.call(x,m,local);
            const onload=()=>{ if(!(x.status>=200&&x.status<300)){ x.removeEventListener('load',onload); _open.call(x,method,original); x.send(); } };
            x.addEventListener('load',onload); return;
          }
          return _open.apply(x,arguments);
        };
        return x;
      };
      __sascTag('SASC','hooks installed (assets local-first with XHR fallback)');
    })();
  </script>

  <!-- Your GUI bundle (keep version tag to bust caches when you change it) -->
  <script src="scratch-gui.js?v=hardrefresh-8"></script>

  <!-- Mount the GUI -->
  <script>
    (function mount(){
      try{
        const app=document.getElementById('app');
        const GUI=window.GUI;
        if (!GUI) { __sascTag('SASC','ERROR: window.GUI missing'); return; }
        if (typeof GUI.setAppElement === 'function') GUI.setAppElement(app);

        if (typeof GUI.render === 'function'){
          GUI.render(app);
          __sascTag('SASC','GUI mounted via GUI.render(app)');
        } else {
          let Wrapped = GUI.default || GUI.GUI || GUI;
          if (typeof GUI.AppStateHOC === 'function') Wrapped = GUI.AppStateHOC(Wrapped);
          if (typeof GUI.ProjectLoaderHOC === 'function') Wrapped = GUI.ProjectLoaderHOC(Wrapped);
          if (typeof GUI.HashParserHOC === 'function') Wrapped = GUI.HashParserHOC(Wrapped);
          const props = {isPlayerOnly:false,isFullScreen:false,canUseCloud:false,projectId:(location.hash&&/\\d+/.test(location.hash))?undefined:'0'};
          const el = window.React.createElement(Wrapped, props);
          window.ReactDOM.render(el, app);
          __sascTag('SASC','GUI mounted via HashParser(ProjectLoader(AppState(GUI))) with projectId='+(props.projectId||'hash'));
        }
      }catch(e){ __sascTag('SASC','BOOT ERROR: '+(e&&e.message)); }
    })();
  </script>

  <!-- VM binder (fiber scan + store subscribe + observer) -->
  <script>
    (function(){
      function fiberKeyOf(n){ if(!n) return null; for(const k in n){ if(k.startsWith('__reactFiber$')||k.startsWith('__reactInternalInstance$')) return k; } return null; }
      function findAnyFiberNode(root){ if(!root) return null; const q=[root]; while(q.length){ const n=q.shift(); if(fiberKeyOf(n)) return n; if(n.shadowRoot) q.push(n.shadowRoot); if(n.childNodes) for(const c of n.childNodes) q.push(c); } return null; }
      function getReactFiberFromDom(node){ const k=fiberKeyOf(node); return k?node[k]:null; }
      function* walkFibers(root){ if(!root) return; const seen=new Set(), stack=[root]; while(stack.length){ const f=stack.pop(); if(!f||seen.has(f)) continue; seen.add(f); yield f; if(f.child) stack.push(f.child); if(f.sibling) stack.push(f.sibling); if(f.return&&!seen.has(f.return)) stack.push(f.return); } }
      function tryExtractStoreFromFiber(f){ try{ const n=f.stateNode; if(n?.store?.getState) return n.store; if(n?.props?.store?.getState) return n.props.store; }catch(_){ } return null; }
      function vmFromStore(store){ try{ const st=store.getState?.(); if(st?.vm?.runtime) return st.vm; if(st?.scratchGui?.vm?.runtime) return st.scratchGui.vm; if(st?.scratch?.vm?.runtime) return st.scratch.vm; }catch(_){ } return null; }

      let bound=false; let observer=null;

      async function bindVM(timeoutMs=15000){
        const t0=Date.now(), app=document.getElementById('app');
        function tryOnce(){
          const GUI=window.GUI||{}; const direct=window.vm||GUI.vm;
          if(direct?.runtime){ window.vm=direct; __sascTag('VM','ready (direct)'); return direct; }
          const host=findAnyFiberNode(app); if(!host) return null;
          const root=getReactFiberFromDom(host); if(!root) return null;
          for(const f of walkFibers(root)){
            const store=tryExtractStoreFromFiber(f);
            if(store){
              try{ const unsub=store.subscribe(()=>{ const v=vmFromStore(store); if(v?.runtime && !bound){ window.vm=v; bound=true; __sascTag('VM','ready (store subscribe)'); try{unsub();}catch(_){}}}); }catch(_){}
              const vNow=vmFromStore(store); if(vNow?.runtime){ window.vm=vNow; __sascTag('VM','ready (store immediate)'); return vNow; }
            }
            try{
              const props=f.memoizedProps||f.pendingProps||(f.stateNode&&f.stateNode.props);
              const state=f.memoizedState||(f.stateNode&&f.stateNode.state);
              for(const c of [props,state,f.stateNode,f]){
                if(!c || typeof c!=='object') continue;
                for(const k in c){ const v=c[k]; if(v && typeof v==='object' && v.runtime && v.runtime.targets){ window.vm=v; __sascTag('VM','ready (fiber props/state)'); return v; } }
              }
            }catch(_){}
          }
          return null;
        }
        if(!observer){
          observer=new MutationObserver(()=>{ if(bound) return; const v=tryOnce(); if(v){ bound=true; } });
          observer.observe(app,{childList:true,subtree:true});
        }
        while(Date.now()-t0<timeoutMs && !bound){
          const v=tryOnce(); if(v){ bound=true; return v; }
          await new Promise(r=>setTimeout(r,250));
          __sascLog('still waiting for VM…');
        }
        if(!bound) __sascLog('rebind: VM not found after fiber scan');
        return bound?window.vm:null;
      }
      window.bindVM = bindVM;
      document.getElementById('btn-bind').onclick=()=>bindVM(10000);
    })();
  </script>
  <!-- Helpers: asset I/O, storage, renderer skins, and robust actions -->
  <script>
    /* ---------- asset helpers ---------- */
    function md5FromMd5ext(md5ext){ return String(md5ext||'').slice(0,32); }
    function isSvgExt(s){ return /\.svg$/i.test(s||''); }
    function extOf(md5ext){ const m=String(md5ext||'').split('.').pop()||''; return m.toLowerCase(); }
    function mimeFromExt(ext){
      if(ext==='svg')return'image/svg+xml'; if(ext==='png')return'image/png';
      if(ext==='jpg'||ext==='jpeg')return'image/jpeg'; if(ext==='gif')return'image/gif';
      if(ext==='wav')return'audio/wav'; if(ext==='mp3')return'audio/mpeg';
      return'application/octet-stream';
    }

    async function fetchAsset(md5ext){
      const ext = extOf(md5ext);
      const local = location.pathname.replace(/\/[^/]*$/,'/').replace(/\/$/,'') + '/static/assets/' + md5ext;

      async function read(res){
        const buf = await res.arrayBuffer();
        const blob = new Blob([buf], {type:mimeFromExt(ext)});
        const text = (ext==='svg') ? await (new Response(blob)).text() : null;
        return {buf, blob, text, ext, isSVG:(ext==='svg'), md5ext};
      }

      // local-first
      try { const r = await fetch(local, {cache:'no-store'}); if(r.ok) return read(r); } catch(_){}
      // CDN fallback
      const cdn = 'https://assets.scratch.mit.edu/internalapi/asset/'+md5ext+'/get/';
      const r2 = await fetch(cdn, {cache:'no-store'});
      if(!r2.ok) throw new Error('CDN '+r2.status);
      return read(r2);
    }

    function costumeModel(name, md5ext){
      const assetId = md5FromMd5ext(md5ext);
      const svg = isSvgExt(md5ext);
      return {
        name: name || ('Costume '+md5ext.slice(0,6)),
        assetId, md5ext,
        dataFormat: svg?'svg':'png',
        rotationCenterX: 240, rotationCenterY: 180,
        ...(svg?{}:{bitmapResolution:2})
      };
    }

    function emitUi(vm){
      try{ vm.runtime.emit('PROJECT_CHANGED'); }catch(_){}
      try{ vm.runtime.emit('targetsUpdate'); }catch(_){}
      try{ vm.emit && vm.emit('targetsUpdate'); }catch(_){}
      try{ vm.runtime.requestTargetsUpdate && vm.runtime.requestTargetsUpdate(); }catch(_){}
      try{ vm.renderer && vm.renderer.draw && vm.renderer.draw(); }catch(_){}
      try{ vm.renderer && (vm.renderer.dirty = true); }catch(_){}
    }

    async function storeImageAsset(vm, asset){
      const storage = vm.runtime?.storage;
      if(!storage) throw new Error('No VM storage');
      const id = md5FromMd5ext(asset.md5ext);
      const type = asset.isSVG ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
      storage.createAsset(type, asset.ext, new Uint8Array(asset.buf), id);
      return id;
    }

    async function applySkin(vm, target, asset){
      if(!vm.renderer || target.drawableID == null) return;
      if(asset.isSVG && vm.renderer.createSVGSkin){
        const svgText = asset.text ?? await (new Response(asset.blob)).text();
        const skinId = vm.renderer.createSVGSkin(svgText);
        vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
      }else if(!asset.isSVG && vm.renderer.createBitmapSkin){
        const bmp = await createImageBitmap(asset.blob);
        const skinId = vm.renderer.createBitmapSkin(bmp, 1);
        vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
      }
      // mark dirty
      try{ vm.renderer._doExitDrawRegion && vm.renderer._doExitDrawRegion(); }catch(_){}
    }

    /* ---------- robust costume injection WITHOUT nuking list (#1, #2) ---------- */
    async function addCostumeToTarget(vm, target, name, md5ext, asset){
      await storeImageAsset(vm, asset);

      // push a new costume (do NOT replace the whole array to preserve thumbnails)
      const model = costumeModel(name, md5ext);
      if(!target.sprite.costumes) target.sprite.costumes = [];
      target.sprite.costumes.push(model);
      // switch to it
      target.setCostume(target.sprite.costumes.length-1);

      // renderer skin to stage immediately
      await applySkin(vm, target, asset);

      emitUi(vm);
    }

    /* ---------- robust backdrop add (#1..#3) ---------- */
    async function addBackdropSmart(name, md5ext){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) throw new Error('vm missing');
      const stage = vm.runtime.getTargetForStage?.();
      if(!stage) throw new Error('No stage target');

      const asset = await fetchAsset(md5ext);

      // try GUI helper
      const GUI = window.GUI;
      if(GUI?.handleBackdropUpload){
        try{
          await GUI.handleBackdropUpload(asset.blob, asset.isSVG?'image/svg+xml':'image/png');
          __sascTag('backdrop','added via GUI.handleBackdropUpload');
          return;
        }catch(e){ __sascTag('backdrop','GUI helper failed: '+(e&&e.message||e)); }
      }

      // try VM helper
      if(typeof vm.addBackdrop === 'function'){
        try{
          await storeImageAsset(vm, asset);
          await vm.addBackdrop(md5ext, costumeModel(name, md5ext));
          __sascTag('backdrop','added via vm.addBackdrop');
          emitUi(vm);
          return;
        }catch(e){ __sascTag('backdrop','vm.addBackdrop failed: '+(e&&e.message||e)); }
      }

      // manual: push into stage costumes (do not replace all)
      await addCostumeToTarget(vm, stage, name, md5ext, asset);
      __sascTag('backdrop','added via manual stage injection');
    }

    /* ---------- robust sprite creation (#1..#4) ---------- */
    async function addSpriteFromMd5(name, md5ext){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) throw new Error('vm missing');
      const asset = await fetchAsset(md5ext);

      // Path 1: vm.addSprite JSON
      if(typeof vm.addSprite === 'function'){
        try{
          await storeImageAsset(vm, asset);
          const spriteObj = {
            isStage:false,
            name: name || 'New Sprite',
            variables:{}, lists:{}, broadcasts:{}, blocks:{}, comments:{},
            currentCostume:0,
            costumes:[costumeModel(name, md5ext)],
            sounds:[],
            volume:100, layerOrder:1, visible:true, x:0, y:0, size:100, direction:90,
            draggable:false, rotationStyle:"all around"
          };
          const id = await vm.addSprite(JSON.stringify(spriteObj));
          const tgt = (vm.runtime.targets||[]).find(t=>t.id===id);
          if(tgt){
            await applySkin(vm, tgt, asset);
            __sascTag('appleA','sprite created via vm.addSprite');
            emitUi(vm);
            return tgt;
          }
        }catch(e){ __sascTag('appleA','vm.addSprite failed: '+(e&&e.message||e)); }
      }

      // Path 2: duplicate first sprite and swap costume (B)
      const sprites = (vm.runtime.targets||[]).filter(t=>!t.isStage);
      if(sprites.length && typeof vm.duplicateSprite === 'function'){
        try{
          const baseId = sprites[0].id;
          const newId = await vm.duplicateSprite(baseId);
          const tgt = (vm.runtime.targets||[]).find(t=>t.id===newId);
          if(!tgt) throw new Error('duplicate ok but target not found');
          try{ await vm.renameSprite(newId, name||'New Sprite'); }catch(_){ if(tgt.sprite) tgt.sprite.name = name||'New Sprite'; }
          await addCostumeToTarget(vm, tgt, name, md5ext, asset);  // push new costume + skin
          __sascTag('appleB','sprite created via duplicate+swap');
          return tgt;
        }catch(e){ __sascTag('appleB','duplicate path failed: '+(e&&e.message||e)); }
      }

      // Path 3: force-create via low-level VM targets (C)
      try{
        await storeImageAsset(vm, asset);
        // Create a minimal sprite from Scratch "sprite3" structure
        const model = {
          isStage:false,
          name: name || 'New Sprite',
          variables:{}, lists:{}, broadcasts:{}, blocks:{}, comments:{},
          currentCostume:0,
          costumes:[costumeModel(name, md5ext)],
          sounds:[],
          volume:100, layerOrder:1, visible:true, x:0, y:0, size:100, direction:90,
          draggable:false, rotationStyle:"all around"
        };
        // Some builds expose fromJSON; if not, addSprite above would have worked.
        if(vm.runtime && vm.runtime.addSprite2){
          const id = await vm.runtime.addSprite2(model);
          const tgt=(vm.runtime.targets||[]).find(t=>t.id===id);
          if(tgt){ await applySkin(vm, tgt, asset); __sascTag('appleC','sprite created via runtime.addSprite2'); emitUi(vm); return tgt; }
        }
      }catch(e){ __sascTag('appleC','low-level create failed: '+(e&&e.message||e)); }

      throw new Error('No sprite creation path available in this build');
    }

    /* ---------- selected target helpers ---------- */
    function getEditingTarget(vm){
      return vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
    }

    /* ---------- add costume to selected ---------- */
    async function addCostumeToSelected(name, md5ext){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) throw new Error('vm missing');
      const t = getEditingTarget(vm);
      if(!t) throw new Error('No editing target');
      const asset = await fetchAsset(md5ext);

      // GUI helper first
      const GUI = window.GUI;
      if(GUI?.handleCostumeUpload){
        try{
          await GUI.handleCostumeUpload(asset.blob, asset.isSVG?'image/svg+xml':'image/png', t.id);
          __sascTag('costume','success via GUI.handleCostumeUpload');
          return;
        }catch(e){ __sascTag('costume','GUI helper failed: '+(e&&e.message||e)); }
      }

      // VM helper
      if(typeof vm.addCostume === 'function'){
        try{
          await storeImageAsset(vm, asset);
          await vm.addCostume(costumeModel(name, md5ext), t.id);
          await applySkin(vm, t, asset);
          __sascTag('costume','success via vm.addCostume (+skin)');
          emitUi(vm);
          return;
        }catch(e){ __sascTag('costume','vm.addCostume failed: '+(e&&e.message||e)); }
      }

      // Manual, guaranteed
      await addCostumeToTarget(vm, t, name, md5ext, asset);
      __sascTag('costume','success via manual injection');
    }

    /* ---------- sounds (best-effort; many builds restrict programmatic add) ---------- */
    async function addSoundToSelected(name, md5ext){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) throw new Error('vm missing');
      const t = getEditingTarget(vm);
      if(!t) throw new Error('No editing target');

      const GUI = window.GUI;
      // md5 path: try to fetch; if local 404s, GUI library is recommended
      if(md5ext){
        let asset=null;
        try{ asset = await fetchAsset(md5ext); }catch(_){/* fall through */ }
        if(asset && GUI?.handleSoundUpload){
          try{
            await GUI.handleSoundUpload(asset.blob, t.id);
            __sascTag('sound','added via GUI.handleSoundUpload');
            return;
          }catch(e){ __sascTag('sound','GUI sound helper failed: '+(e&&e.message||e)); }
        }
        if(typeof vm.addSound === 'function'){
          try{
            const id = md5FromMd5ext(md5ext);
            const snd={ name:name||('Sound '+md5ext.slice(0,6)), assetId:id, md5ext, dataFormat:extOf(md5ext), rate:44100, sampleCount:0 };
            await vm.addSound(md5ext, snd, t.id);
            __sascTag('sound','added via vm.addSound');
            emitUi(vm);
            return;
          }catch(e){ __sascTag('sound','vm.addSound failed: '+(e&&e.message||e)); }
        }
      }

      // fallback: open Sound Library so user can pick (works everywhere)
      __sascTag('sound','sound upload not supported in this build (use Sound Library or Sounds tab)');
      try{ openSoundLibrary(); }catch(_){}
      throw new Error('No sound upload path available in this build');
    }

    /* ---------- file-input helpers for “from file” (C options) ---------- */
    function selectLocalImageFile(){
      return new Promise((resolve,reject)=>{
        const el = document.getElementById('file-image');
        el.value = ''; // clear previous
        el.onchange = async () => {
          if(!el.files || !el.files[0]) return reject(new Error('no file'));
          const f = el.files[0];
          const ext = (f.name.split('.').pop()||'').toLowerCase();
          const buf = await f.arrayBuffer();
          const blob = new Blob([buf], {type:mimeFromExt(ext)});
          const text = (ext==='svg') ? await (new Response(blob)).text() : null;
          resolve({buf, blob, text, ext, isSVG:(ext==='svg'), md5ext: (crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g,'').slice(0,32) : (Date.now().toString(16).padEnd(32,'0'))) + '.' + ext});
        };
        el.click();
      });
    }
    function selectLocalSoundFile(){
      return new Promise((resolve,reject)=>{
        const el = document.getElementById('file-sound');
        el.value = '';
        el.onchange = async () => {
          if(!el.files || !el.files[0]) return reject(new Error('no file'));
          const f = el.files[0];
          const ext = (f.name.split('.').pop()||'').toLowerCase();
          const buf = await f.arrayBuffer();
          const blob = new Blob([buf], {type:mimeFromExt(ext)});
          resolve({buf, blob, text:null, ext, isSVG:false, md5ext: (crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g,'').slice(0,32) : (Date.now().toString(16).padEnd(32,'0'))) + '.' + ext});
        };
        el.click();
      });
    }
  </script>
  <!-- UI wiring: open libraries, diagnostics (Apple A/B/C), Backdrop A/B/C, Sound A/B/C -->
  <script>
    /* ---------- find & click built-in GUI buttons (like on scratch.mit.edu) ---------- */
    function clickByAriaContains(text) {
      const all = document.querySelectorAll('[aria-label]');
      for (const el of all) {
        const v = (el.getAttribute('aria-label') || '').toLowerCase();
        if (v.includes(text.toLowerCase())) { el.click(); return true; }
      }
      return false;
    }
    function clickByTitleContains(text) {
      const all = document.querySelectorAll('[title]');
      for (const el of all) {
        const v = (el.getAttribute('title') || '').toLowerCase();
        if (v.includes(text.toLowerCase())) { el.click(); return true; }
      }
      return false;
    }
    function clickByTextContains(text) {
      const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null);
      let node;
      while ((node = walker.nextNode())) {
        const t = (node.textContent || '').trim().toLowerCase();
        if (t && t.includes(text.toLowerCase())) { node.click(); return true; }
      }
      return false;
    }

    function openSpriteLibrary() {
      if (clickByAriaContains('choose a sprite')) { __sascTag('ui','opened Sprite Library via aria-label'); return; }
      if (clickByTitleContains('sprite')) { __sascTag('ui','opened Sprite Library via title'); return; }
      if (clickByTextContains('choose a sprite')) { __sascTag('ui','opened Sprite Library via text'); return; }
      __sascTag('ui','Sprite Library button not found in this layout');
    }
    function openBackdropLibrary() {
      if (clickByAriaContains('choose a backdrop')) { __sascTag('ui','opened Backdrop Library via aria-label'); return; }
      if (clickByTitleContains('backdrop')) { __sascTag('ui','opened Backdrop Library via title'); return; }
      if (clickByTextContains('choose a backdrop')) { __sascTag('ui','opened Backdrop Library via text'); return; }
      __sascTag('ui','Backdrop Library button not found in this layout');
    }
    function openCostumeLibrary() {
      if (clickByAriaContains('choose a costume')) { __sascTag('ui','opened Costume Library via aria-label'); return; }
      if (clickByTitleContains('costume')) { __sascTag('ui','opened Costume Library via title'); return; }
      if (clickByTextContains('choose a costume')) { __sascTag('ui','opened Costume Library via text'); return; }
      __sascTag('ui','Costume Library button not found in this layout');
    }
    function openSoundLibrary() {
      if (clickByAriaContains('choose a sound')) { __sascTag('ui','opened Sound Library via aria-label'); return; }
      if (clickByTitleContains('sound')) { __sascTag('ui','opened Sound Library via title'); return; }
      if (clickByTextContains('choose a sound')) { __sascTag('ui','opened Sound Library via text'); return; }
      __sascTag('ui','Sound Library button not found in this layout');
    }

    /* ---------- diagnostics & explicit A/B/C paths ---------- */
    const APPLE_MD5 = '3826a4091a33e4d26f87a2fac7cf796b.svg';
    const SKY_MD5   = 'e7c147730f19d284bcd7b3f00af19bb6.svg';
    const POP_MD5   = '83c36d806dc92327b9e7049a565c6bff.wav';

    // Explicit Apple A (vm.addSprite only), B (duplicate), C (local file)
    async function addAppleA(){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('appleA','vm missing');
      const asset = await fetchAsset(APPLE_MD5);
      if(typeof vm.addSprite !== 'function'){ __sascTag('appleA','vm.addSprite unavailable'); return; }
      try{
        await storeImageAsset(vm, asset);
        const spriteObj = {
          isStage:false, name:'Apple (A)', variables:{}, lists:{}, broadcasts:{}, blocks:{}, comments:{},
          currentCostume:0, costumes:[costumeModel('Apple', APPLE_MD5)], sounds:[],
          volume:100, layerOrder:1, visible:true, x:0, y:0, size:100, direction:90, draggable:false, rotationStyle:"all around"
        };
        const id = await vm.addSprite(JSON.stringify(spriteObj));
        const tgt=(vm.runtime.targets||[]).find(t=>t.id===id);
        if(tgt){ await applySkin(vm,tgt,asset); __sascTag('appleA','sprite created via vm.addSprite'); emitUi(vm); }
        else __sascTag('appleA','created but target not found');
      }catch(e){ __sascTag('appleA','failed: '+(e&&e.message||e)); }
    }
    async function addAppleB(){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('appleB','vm missing');
      const sprites=(vm.runtime.targets||[]).filter(t=>!t.isStage);
      if(!sprites.length || typeof vm.duplicateSprite!=='function'){ __sascTag('appleB','duplicate path unavailable'); return; }
      try{
        const asset = await fetchAsset(APPLE_MD5);
        const newId = await vm.duplicateSprite(sprites[0].id);
        const tgt=(vm.runtime.targets||[]).find(t=>t.id===newId);
        if(!tgt) throw new Error('duplicate ok but target not found');
        try{ await vm.renameSprite(newId,'Apple (B)'); }catch(_){ if(tgt.sprite) tgt.sprite.name='Apple (B)'; }
        await addCostumeToTarget(vm, tgt, 'Apple', APPLE_MD5, asset); // push + skin
        __sascTag('appleB','sprite created via duplicate+swap');
      }catch(e){ __sascTag('appleB','failed: '+(e&&e.message||e)); }
    }
    async function addAppleC(){
      const vm = window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('appleC','vm missing');
      try{
        const asset = await selectLocalImageFile();
        const id = await storeImageAsset(vm, asset);
        const spriteObj = {
          isStage:false, name:'Apple (C: file)', variables:{}, lists:{}, broadcasts:{}, blocks:{}, comments:{},
          currentCostume:0, costumes:[costumeModel('Local', asset.md5ext)], sounds:[],
          volume:100, layerOrder:1, visible:true, x:0, y:0, size:100, direction:90, draggable:false, rotationStyle:"all around"
        };
        if(typeof vm.addSprite === 'function'){
          const newId = await vm.addSprite(JSON.stringify(spriteObj));
          const tgt=(vm.runtime.targets||[]).find(t=>t.id===newId);
          if(tgt){ await applySkin(vm,tgt,asset); __sascTag('appleC','sprite created from local file via vm.addSprite'); emitUi(vm); return; }
        }
        __sascTag('appleC','vm.addSprite unavailable; try Apple B or open Sprite Library');
      }catch(e){ __sascTag('appleC','file path failed: '+(e&&e.message||e)); }
    }

    // Backdrop A (GUI), B (vm.addBackdrop), C (manual)
    async function addBackdropA(){
      const GUI=window.GUI;
      const vm=window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('backdrop','vm missing');
      try{
        const asset = await fetchAsset(SKY_MD5);
        if(GUI?.handleBackdropUpload){
          await GUI.handleBackdropUpload(asset.blob, asset.isSVG?'image/svg+xml':'image/png');
          __sascTag('backdrop','added via GUI.handleBackdropUpload');
        }else{
          __sascTag('backdrop','GUI helper not available; try B or C');
        }
      }catch(e){ __sascTag('backdrop','A failed: '+(e&&e.message||e)); }
    }
    async function addBackdropB(){
      const vm=window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('backdrop','vm missing');
      try{
        const asset = await fetchAsset(SKY_MD5);
        if(typeof vm.addBackdrop === 'function'){
          await storeImageAsset(vm, asset);
          await vm.addBackdrop(SKY_MD5, costumeModel('Sky', SKY_MD5));
          __sascTag('backdrop','added via vm.addBackdrop');
          emitUi(vm);
        }else{
          __sascTag('backdrop','vm.addBackdrop unavailable; try A or C');
        }
      }catch(e){ __sascTag('backdrop','B failed: '+(e&&e.message||e)); }
    }
    async function addBackdropC(){
      const vm=window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('backdrop','vm missing');
      const stage = vm.runtime.getTargetForStage?.();
      if(!stage) return __sascTag('backdrop','stage missing');
      try{
        const asset = await selectLocalImageFile();
        await addCostumeToTarget(vm, stage, 'Local Backdrop', asset.md5ext, asset);
        __sascTag('backdrop','added via manual stage injection (file)');
      }catch(e){ __sascTag('backdrop','C failed: '+(e&&e.message||e)); }
    }

    // Sound A (open Library), B (md5 via GUI/vm), C (local file via GUI)
    async function addSoundA(){
      openSoundLibrary();
    }
    async function addSoundB(){
      try{
        await addSoundToSelected('Pop', POP_MD5);
      }catch(e){ __sascTag('sound','B failed: '+(e&&e.message||e)); }
    }
    async function addSoundC(){
      const vm=window.vm || await (window.bindVM? window.bindVM(6000):null);
      if(!vm?.runtime) return __sascTag('sound','vm missing');
      const t = getEditingTarget(vm);
      if(!t) return __sascTag('sound','No editing target');
      const GUI=window.GUI;
      try{
        const asset = await selectLocalSoundFile();
        if(GUI?.handleSoundUpload){
          await GUI.handleSoundUpload(asset.blob, t.id);
          __sascTag('sound','added local file via GUI.handleSoundUpload');
          return;
        }
        __sascTag('sound','GUI sound upload not available; use Sound Library');
        openSoundLibrary();
      }catch(e){ __sascTag('sound','C failed: '+(e&&e.message||e)); }
    }

    /* ---------- wire buttons ---------- */
    document.getElementById('btn-targets').onclick=()=>{
      const vm=window.vm; if(!vm||!vm.runtime) return __sascTag('targets','VM not ready');
      const ts=vm.runtime.targets||[]; __sascLog('[targets] '+ts.length+' targets');
      ts.forEach(t=>__sascLog('- ['+(t.isStage?'STAGE':'SPRITE')+'] '+(t.getName?t.getName():t.sprite?.name||'(?)')));
    };

    // Library openers
    document.getElementById('btn-lib-sprite').onclick=openSpriteLibrary;
    document.getElementById('btn-lib-backdrop').onclick=openBackdropLibrary;
    document.getElementById('btn-lib-costume').onclick=openCostumeLibrary;
    document.getElementById('btn-lib-sound').onclick=openSoundLibrary;

    // Sprite by md5 / from file (generic)
    document.getElementById('btn-sprite-b').onclick=async()=>{
      try{
        const md5ext=prompt('Sprite costume md5.ext (svg/png):', APPLE_MD5);
        if(!md5ext) return;
        await addSpriteFromMd5('Sprite (md5)', md5ext.trim());
      }catch(e){ __sascTag('tools','sprite by md5 failed: '+(e&&e.message||e)); }
    };
    document.getElementById('btn-sprite-c').onclick=addAppleC; // reuse “file” logic

    // Backdrop by md5 / from file (generic)
    document.getElementById('btn-bg-b').onclick=async()=>{
      try{
        const md5ext=prompt('Backdrop md5.ext (svg/png):', SKY_MD5);
        if(!md5ext) return;
        // favor B path explicitly
        const vm=window.vm || await (window.bindVM? window.bindVM(6000):null);
        if(!vm?.runtime) return __sascTag('backdrop','vm missing');
        const asset = await fetchAsset(md5ext.trim());
        if(typeof vm.addBackdrop === 'function'){
          await storeImageAsset(vm, asset);
          await vm.addBackdrop(md5ext.trim(), costumeModel('Backdrop', md5ext.trim()));
          __sascTag('backdrop','added via vm.addBackdrop (prompt)');
          emitUi(vm);
        }else{
          await addBackdropSmart('Backdrop', md5ext.trim()); // fallback to A/C internally
        }
      }catch(e){ __sascTag('tools','backdrop md5 failed: '+(e&&e.message||e)); }
    };
    document.getElementById('btn-bg-c').onclick=addBackdropC;

    // Sound by md5 / from file
    document.getElementById('btn-snd-b').onclick=addSoundB;
    document.getElementById('btn-snd-c').onclick=addSoundC;

    // Diagnostic Apples
    document.getElementById('btn-apple-a').onclick=addAppleA;
    document.getElementById('btn-apple-b').onclick=addAppleB;
    document.getElementById('btn-apple-c').onclick=addAppleC;

    // Auto-bind after mount
    (window.bindVM||(()=>Promise.resolve(null)))(20000);
  </script>
</body>
</html>
