<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (fiber-binder)</title>
  <link rel="icon" href="./favicon.ico"/> 

  <style>
    html,body,#app{height:100%;margin:0}
    #app{display:flex;align-items:stretch;justify-content:stretch;background:#0b1120}

    /* SASC console */
    #sasc-console{position:fixed;left:10px;bottom:10px;width:420px;max-height:56vh;background:#111a;backdrop-filter:blur(2px);
      color:#0ff;font:12px/1.35 ui-monospace,Consolas,monospace;border:1px solid #044;border-radius:8px;z-index:99999}
    #sasc-console header{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:6px 8px;background:#022;border-bottom:1px solid #044;border-radius:8px 8px 0 0}
    #sasc-console header strong{margin-right:auto}
    #sasc-console pre{margin:0;padding:6px 8px;white-space:pre-wrap;overflow:auto;max-height:calc(56vh - 46px)}
    #sasc-console button{all:unset;cursor:pointer;color:#0ff;padding:2px 6px;border:1px solid #044;border-radius:6px}
    #sasc-console button:hover{background:#033}

    /* Minimal layout shim (keeps UI usable even if demo CSS fails) */
    [class*="gui-body"]{display:flex;min-height:100vh}
    [class*="blockly"],[class*="blocks"]{min-width:280px;flex:1 1 50%}
    [class*="target-pane"]{min-width:240px;flex:0 0 240px}
    [class*="stage-wrapper"]{position:relative;z-index:0;flex:0 0 auto}
    [class*="stage-header"]{position:relative;z-index:2}
    [class*="green-flag"],[class*="stop-all"]{position:relative;z-index:3}
    canvas{cursor:default}
    [class*="react-modal"],[class*="modal-content"]{z-index:9999;position:relative}
    [class*="sprite-selector"] img{display:block}
  </style>

  <!-- SASC console bootstrap -->
  <script>
    (function(){
      const node = document.createElement('div');
      node.id = 'sasc-console';
      node.innerHTML = `
        <header>
          <strong>SASC</strong>
          <button id="btn-clear">Clear</button>
          <button id="btn-rebind">Force rebind VM</button>
          <button id="btn-targets">List Targets</button>
          <button id="btn-apple">+ Apple (sprite)</button>
          <button id="btn-backdrop-sky">+ Blue Sky → Backdrop</button>
        </header>
        <pre>SASC clear\n</pre>`;
      document.addEventListener('DOMContentLoaded', ()=>document.body.appendChild(node));
      window.__sascLog = (m)=>{
        try{
          const pre = document.querySelector('#sasc-console pre');
          pre.textContent += m+'\n';
          pre.scrollTop = pre.scrollHeight;
        }catch(_){}
        console.log(m);
      };
      document.addEventListener('DOMContentLoaded', ()=>{
        const pre = document.querySelector('#sasc-console pre');
        document.getElementById('btn-clear').onclick = ()=>{ pre.textContent = 'SASC clear\n'; };
      });
      window.addEventListener('click', e => __sascLog('[Click] ' + e.target.tagName));
      window.addEventListener('unhandledrejection', e => __sascLog('[unhandledrejection]: ' + (e.reason && (e.reason.stack || e.reason))));
    })();
  </script>
</head>
<body>
  <div id="app"></div>

  <!-- React UMDs -->
  <script src="https://unpkg.com/react@16.14.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@16.14.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>

  <!-- Local-first fetch/XHR hooks -->
  <script>
  (function(){
    const base = location.pathname.replace(/\/[^/]*$/, '/'); // /<user>/<repo>/
    const repoRoot = base.replace(/\/$/, '');
    const toLocal = (u)=>{
      const m = u && u.match(/internalapi\/asset\/([a-f0-9]{32}\.(?:sprite3|json|svg|png|gif|jpg|wav|mp3))\/get\/?/i);
      return m ? (repoRoot + '/static/assets/' + m[1]) : null;
    };

    const f = window.fetch;
    window.fetch = async function(i,init){
      const url = (typeof i==='string') ? i : (i && i.url);
      const local = toLocal(url);
      if (local){
        try{
          const r = await f(local, init);
          if (r && r.ok){ __sascLog('[hooks] fetch local OK → '+local); return r; }
          __sascLog('[hooks] fetch local '+(r&&r.status)+' → fallback '+url);
        }catch(e){ __sascLog('[hooks] fetch local error → fallback '+e); }
      }
      return f.apply(this, arguments);
    };

    const XO = XMLHttpRequest;
    window.XMLHttpRequest = function(){
      const x = new XO(); let original=null, method='GET';
      const _open=x.open;
      x.open=function(m,u){
        method=m; original=u;
        const local = (typeof u==='string') ? toLocal(u) : null;
        if (local){
          _open.call(x, m, local);
          const onload = function(){
            if (x.status>=200 && x.status<300){ __sascLog('[hooks] xhr local OK → '+local); }
            else { __sascLog('[hooks] xhr local '+x.status+' → retry ORIGINAL '+original); x.removeEventListener('load', onload); _open.call(x, method, original); x.send(); }
          };
          x.addEventListener('load', onload);
          return;
        }
        return _open.apply(x, arguments);
      };
      const _send=x.send; x.send=function(){ return _send.apply(x, arguments); };
      __sascLog('[hooks] installed (assets local-first with XHR fallback)');
      return x;
    };
  })();
  </script>

  <!-- 🔍 React Fiber binder (no dependency on window.Redux) -->
  <script>
  (function(){
    const log = (m)=> (window.__sascLog ? __sascLog(m) : console.log('[SASC]', m));
    let vmRef = null;

    function attachVM(vm, via){
      if (!vm || !vm.runtime) return false;
      vmRef = vm; window.vm = vmRef;
      const n = (vm.runtime.targets && vm.runtime.targets.length) || 0;
      log(`[fiber] VM attached via ${via} (targets=${n})`);
      return true;
    }

    function looksLikeVM(x){
      return x && typeof x==='object'
        && x.runtime && typeof x.runtime==='object'
        && Array.isArray(x.runtime.targets)
        && typeof x.addSprite==='function';
    }

    function scanStateForVM(state){
      // try common path first
      try{
        const vm = state && state.scratchGui && state.scratchGui.vm;
        if (looksLikeVM(vm)) return vm;
      }catch(_){}
      // generic DFS
      const seen = new Set();
      const stack = [state];
      let count = 0, max = 30000;
      while (stack.length && count < max){
        const cur = stack.pop(); count++;
        if (!cur || typeof cur!=='object') continue;
        if (seen.has(cur)) continue; seen.add(cur);
        if (looksLikeVM(cur)) return cur;
        for (const k in cur){ const v = cur[k]; if (v && typeof v==='object' && !seen.has(v)) stack.push(v); }
      }
      return null;
    }

    function tryReactFiberProbe(rootEl){
      // find React fiber on #app or its first child container
      const keys = Object.keys(rootEl);
      const fiberKey = keys.find(k => k.startsWith('__reactFiber$')) || keys.find(k => k.startsWith('__reactContainer'));
      const fiber = fiberKey ? rootEl[fiberKey] : null;
      if (!fiber){ log('still waiting for VM…'); return false; }

      // walk fiber tree depth-first
      const stack = [fiber];
      const seen = new Set();
      while (stack.length){
        const node = stack.pop();
        if (!node || seen.has(node)) continue;
        seen.add(node);

        const props = node.memoizedProps || node.pendingProps || null;
        const stateNode = node.stateNode || null;

        // 1) vm on props/stateNode
        if (props && props.vm && looksLikeVM(props.vm)) return attachVM(props.vm, 'fiber:props.vm');
        if (stateNode && stateNode.vm && looksLikeVM(stateNode.vm)) return attachVM(stateNode.vm, 'fiber:stateNode.vm');

        // 2) Redux store in stateNode (Provider)
        const store = stateNode && stateNode.store && typeof stateNode.store.getState==='function' ? stateNode.store : null;
        if (store){
          try{
            const st = store.getState();
            const vm = scanStateForVM(st);
            if (vm) return attachVM(vm, 'fiber:redux store');
          }catch(_){}
        }

        // push children
        if (node.child) stack.push(node.child);
        if (node.sibling) stack.push(node.sibling);
      }
      log('still waiting for VM…');
      return false;
    }

    // Expose force rebind
    window.__SASC_BINDER = {
      get vm(){ return vmRef; },
      forceRebind: ()=> tryReactFiberProbe(document.getElementById('app'))
    };

    // Poll until fiber appears & vm found
    const app = document.getElementById('app');
    const timer = setInterval(()=>{
      if (vmRef && vmRef.runtime) { clearInterval(timer); return; }
      tryReactFiberProbe(app);
    }, 400);
  })();
  </script>

  <!-- Your GUI bundle -->
  <script src="scratch-gui.js?v=stable-boot-clean-index"></script>

  <!-- Mount GUI -->
  <script>
  (function bootGUI(){
    try{
      const app = document.getElementById('app');
      const GUI = window.GUI;
      if (!GUI) { __sascLog('ERROR: window.GUI missing'); return; }
      if (typeof GUI.setAppElement === 'function') GUI.setAppElement(app);

      let Wrapped = GUI.default || GUI.GUI || GUI;
      if (typeof GUI.AppStateHOC === 'function') Wrapped = GUI.AppStateHOC(Wrapped);
      if (typeof GUI.ProjectLoaderHOC === 'function') Wrapped = GUI.ProjectLoaderHOC(Wrapped);
      if (typeof GUI.HashParserHOC === 'function') Wrapped = GUI.HashParserHOC(Wrapped);

      const el = window.React.createElement(Wrapped, {
        isPlayerOnly:false,isFullScreen:false,canUseCloud:false,
        projectId:(location.hash && /\d+/.test(location.hash)) ? undefined : '0'
      });
      window.ReactDOM.render(el, app);
      __sascLog('GUI mounted via HashParser(ProjectLoader(AppState(GUI))) with projectId=0');
    }catch(e){
      __sascLog('BOOT ERROR: ' + (e.stack || e));
    }
  })();
  </script>

  <!-- Tools (Apple / Backdrop) -->
  <script>
  (function tools(){
    const APPLE_SVG = '3826a4091a33e4d26f87a2fac7cf796b.svg';
    const SKY_SVG   = 'e7c147730f19d284bcd7b3f00af19bb6.svg';

    function repoBase(){ return location.pathname.replace(/\/[^/]*$/, '/').replace(/\/$/, ''); }
    function parseAsset(md5ext){ const m=String(md5ext||'').match(/^([a-f0-9]{32})\.(\w+)$/i); return m?{assetId:m[1],ext:m[2].toLowerCase()}:null; }
    async function fetchAsset(md5ext){
      const local = repoBase() + '/static/assets/' + md5ext;
      try{ const r=await fetch(local,{cache:'no-store'}); if(r.ok){ const arr=await r.arrayBuffer(); return {arr}; } }catch(_){}
      const cdn='https://assets.scratch.mit.edu/internalapi/asset/'+md5ext+'/get/'; const r2=await fetch(cdn,{cache:'no-store'});
      if(!r2.ok) throw new Error('CDN fetch '+r2.status); const arr=await r2.arrayBuffer(); return {arr};
    }
    function costumeObj(name, md5ext){ const p=parseAsset(md5ext)||{ext:'png',assetId:''};
      return {name,assetId:p.assetId,md5ext,dataFormat:(p.ext==='svg'?'svg':p.ext),rotationCenterX:240,rotationCenterY:180}; }
    function stage(vm){ return vm && vm.runtime && vm.runtime.getTargetForStage ? vm.runtime.getTargetForStage() : null; }
    const binderVM = ()=> (window.__SASC_BINDER && window.__SASC_BINDER.vm) || window.vm;

    async function addApple(){
      const vm = binderVM();
      if (!vm || !vm.addSprite){ __sascLog('[tools] vm not ready for addSprite'); return; }
      try{ const {arr} = await fetchAsset(APPLE_SVG); await vm.addSprite(new Uint8Array(arr)); __sascLog('[tools] Apple sprite added'); }
      catch(e){ __sascLog('[tools] Apple add failed: ' + (e && e.message || e)); }
    }

    async function addSkyAsBackdrop(){
      const vm = binderVM();
      if (!vm){ __sascLog('[tools] VM not found yet'); return; }
      const st = stage(vm); if (!st){ __sascLog('[tools] No stage target'); return; }
      const cos = costumeObj('Blue Sky', SKY_SVG);

      try{ if (typeof vm.addBackdrop==='function'){ await vm.addBackdrop(SKY_SVG, cos); __sascLog('[tools] Blue Sky backdrop via vm.addBackdrop ✅'); return; } }
      catch(e){ __sascLog('[tools] vm.addBackdrop failed: ' + (e && e.message || e)); }

      try{ if (typeof vm.addCostume==='function'){ await vm.addCostume(cos, st.id); __sascLog('[tools] Blue Sky backdrop via vm.addCostume ✅'); return; } }
      catch(e){ __sascLog('[tools] vm.addCostume(stage) failed: ' + (e && e.message || e)); }

      try{
        const {arr} = await fetchAsset(SKY_SVG);
        const storage = vm.runtime && vm.runtime.storage; if (!storage) throw new Error('No VM storage');
        const p = parseAsset(SKY_SVG)||{ext:'svg', assetId:''};
        const type = (p.ext==='svg') ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
        storage.createAsset(type, p.ext, new Uint8Array(arr), p.assetId);
        st.sprite.costumes.push(cos);
        const idx = st.sprite.costumes.length - 1;
        st.setCostume(idx);
        try { vm.runtime.emit('PROJECT_CHANGED'); } catch(_){}
        __sascLog('[tools] Blue Sky backdrop via manual injection ✅');
      }catch(e){ __sascLog('[tools] manual backdrop failed: ' + (e && e.message || e)); }
    }

    document.addEventListener('DOMContentLoaded', ()=>{
      document.getElementById('btn-rebind').onclick = ()=> window.__SASC_BINDER && window.__SASC_BINDER.forceRebind();
      document.getElementById('btn-targets').onclick = ()=>{
        const vm = binderVM();
        if (!vm || !vm.runtime || !vm.runtime.targets){ __sascLog('[targets] VM not ready'); return; }
        const ts = vm.runtime.targets.map(t => (t.isStage?'[STAGE] ':'[SPRITE] ') + (t.getName ? t.getName() : t.sprite && t.sprite.name));
        __sascLog('[targets] ' + vm.runtime.targets.length + ' targets\n- ' + ts.join('\n- '));
      };
      document.getElementById('btn-apple').onclick = addApple;
      document.getElementById('btn-backdrop-sky').onclick = addSkyAsBackdrop;
    });
  })();
  </script>
</body>
</html>
