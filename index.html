<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (fiber-scan+observer)</title>
  <link rel="icon" href="./favicon.ico"/>

  <style>
    html,body,#app{height:100%;margin:0}
    #app{display:flex;align-items:stretch;justify-content:stretch;background:#0b1120}

    /* SASC console */
    #sasc-console{position:fixed;left:10px;bottom:10px;width:380px;max-height:52vh;background:#0b0e;backdrop-filter:blur(2px);
      color:#0ff;font:12px/1.35 ui-monospace,Consolas,monospace;border:1px solid #044;border-radius:8px;z-index:99999}
    #sasc-console[data-theme="light"]{background:#fff9;color:#034;border-color:#89a}
    #sasc-console header{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:6px 8px;background:#022;border-bottom:1px solid #044;border-radius:8px 8px 0 0}
    #sasc-console[data-theme="light"] header{background:#eaf2ff;border-bottom-color:#89a}
    #sasc-console header strong{margin-right:auto}
    #sasc-console pre{margin:0;padding:6px 8px;white-space:pre-wrap;overflow:auto;max-height:calc(52vh - 44px)}
    #sasc-console button{all:unset;cursor:pointer;color:inherit;padding:2px 6px;border:1px solid currentColor;border-radius:6px}
    #sasc-console .btnrow button{margin-left:4px}

    /* Minimal layout shim so GUI renders */
    [class*="gui-body"]{display:flex;min-height:100vh}
    [class*="stage-wrapper"]{position:relative;z-index:0;flex:0 0 auto}
    [class*="stage-header"]{position:relative;z-index:2}
    [class*="green-flag"],[class*="stop-all"]{position:relative;z-index:3}
    [class*="blockly"],[class*="blocks"]{min-width:280px;flex:1 1 50%}
    [class*="target-pane"]{min-width:240px;flex:0 0 240px}
    [class*="react-modal"],[class*="modal-content"]{z-index:9999;position:relative}
    canvas{cursor:default}
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- SASC console -->
  <div id="sasc-console">
    <header>
      <strong>SASC</strong>
      <button id="btn-clear">Clear</button>
      <button id="btn-contrast">Contrast</button>
      <span class="btnrow">
        <button id="btn-bind">Bind VM</button>
        <button id="btn-targets">List Targets</button>
        <button id="btn-apple">Add Apple Sprite</button>
        <button id="btn-backdrop">Add Backdrop (md5.ext)…</button>
        <button id="btn-costume">Add Costume…</button>
        <button id="btn-sound">Add Sound…</button>
      </span>
    </header>
    <pre>SASC clear
</pre>
  </div>

  <!-- Console wiring -->
  <script>
  /* ---------- small helpers ---------- */
  function costumeFromMd5(name, md5ext){
    const isSVG = /\.svg$/i.test(md5ext);
    const assetId = md5ext.slice(0,32);
    return {
      name: name || ('Costume '+md5ext.slice(0,6)),
      assetId,
      md5ext,
      dataFormat: isSVG ? 'svg' : 'png',
      rotationCenterX: 240,
      rotationCenterY: 180,
      ...(isSVG ? {} : {bitmapResolution:2, rotationCenterX:240, rotationCenterY:180})
    };
  }

  async function fetchAsset(md5ext){
    const ext = md5ext.split('.').pop().toLowerCase();
    const isSVG = ext === 'svg';
    const base = location.pathname.replace(/\/[^/]*$/,'/').replace(/\/$/,'');
    const local = base + '/static/assets/' + md5ext;
    async function read(res){
      const buf = await res.arrayBuffer();
      const blob = new Blob([buf], {type: isSVG ? 'image/svg+xml' :
                                           ext==='png' ? 'image/png' :
                                           (ext==='jpg'||ext==='jpeg') ? 'image/jpeg' :
                                           ext==='gif' ? 'image/gif' :
                                           ext==='wav' ? 'audio/wav' :
                                           ext==='mp3' ? 'audio/mp3' :
                                           'application/octet-stream'});
      const text = isSVG ? await (new Response(blob)).text() : null;
      return {buf, blob, text, ext, isSVG};
    }
    try{ const rLocal = await fetch(local,{cache:'no-store'}); if(rLocal.ok) return read(rLocal);}catch(_){}
    const cdn='https://assets.scratch.mit.edu/internalapi/asset/'+md5ext+'/get/';
    const rCdn=await fetch(cdn,{cache:'no-store'}); if(!rCdn.ok) throw new Error('CDN '+rCdn.status);
    return read(rCdn);
  }

  function emitUiUpdates(vm){
    try{ vm.runtime.emit('PROJECT_CHANGED'); }catch(_){}
    try{ vm.runtime.emit('targetsUpdate'); }catch(_){}
    try{ vm.emit && vm.emit('targetsUpdate'); }catch(_){}
  }

  /* ---------- attach image data to storage + renderer (manual path) ---------- */
  async function applyCostumeToTarget(vm, target, md5ext, asset, opts={}){
    const storage = vm.runtime?.storage; if(!storage) throw new Error('No VM storage');
    const id = md5ext.slice(0,32);
    const type = asset.isSVG ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
    storage.createAsset(type, asset.ext, new Uint8Array(asset.buf), id);

    // add/replace costume model first so GUI has an entry for thumbnails
    const costume = costumeFromMd5(opts.name || null, md5ext);
    if (opts.replaceAll) {
      target.sprite.costumes = [costume];
      target.setCostume(0);
    } else {
      target.sprite.costumes.push(costume);
      target.setCostume(target.sprite.costumes.length-1);
    }

    // renderer skin so Stage updates instantly
    if (vm.renderer && target.drawableID != null) {
      if (asset.isSVG && vm.renderer.createSVGSkin) {
        const svgText = asset.text ?? await (new Response(asset.blob)).text();
        const skinId = vm.renderer.createSVGSkin(svgText);
        vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
      } else if (!asset.isSVG && vm.renderer.createBitmapSkin) {
        const bmp = await createImageBitmap(asset.blob);
        const skinId = vm.renderer.createBitmapSkin(bmp, 1);
        vm.renderer.updateDrawableProperties(target.drawableID, {skinId});
      }
    }

    emitUiUpdates(vm);
  }

  /* ---------- create a sprite (duplicate → fallback to addSprite) ---------- */
  async function addSpriteFromCostume(name, md5ext){
    const vm = window.vm || await bindVM(6000);
    if(!vm?.runtime) throw new Error('vm missing');

    const asset = await fetchAsset(md5ext);

    // 1) Preferred: VM native addSprite (works across many builds)
    if (typeof vm.addSprite === 'function') {
      const spriteObj = {
        isStage:false,
        name: name || 'New Sprite',
        variables:{}, lists:{}, broadcasts:{}, blocks:{}, comments:{},
        currentCostume:0,
        costumes:[costumeFromMd5(name, md5ext)],
        sounds:[],
        volume:100,
        layerOrder:1, visible:true, x:0, y:0, size:100, direction:90,
        draggable:false, rotationStyle:"all around"
      };
      const id = await vm.addSprite(JSON.stringify(spriteObj));
      const tgt = (vm.runtime.targets||[]).find(t=>t.id===id);
      if (tgt) {
        // ensure skin bytes exist & Stage updates
        await applyCostumeToTarget(vm, tgt, md5ext, asset, {replaceAll:true, name});
        __sascTag('tools','sprite created via vm.addSprite');
        return;
      }
    }

    // 2) Fallback: duplicate existing sprite if available
    const sprites = (vm.runtime.targets||[]).filter(t=>!t.isStage);
    if (sprites.length && typeof vm.duplicateSprite === 'function') {
      const baseId = sprites[0].id;
      const newId = await vm.duplicateSprite(baseId).catch(()=>null);
      if (!newId) throw new Error('duplicateSprite failed');
      const tgt = (vm.runtime.targets||[]).find(t=>t.id===newId);
      if (!tgt) throw new Error('New sprite target not found');
      try{ await vm.renameSprite(newId, name||'New Sprite'); }catch(_){ if(tgt.sprite) tgt.sprite.name = name||'New Sprite'; }
      await applyCostumeToTarget(vm, tgt, md5ext, asset, {replaceAll:true, name});
      __sascTag('tools','sprite created via duplicate+swap');
      return;
    }

    throw new Error('No sprite creation path available in this build');
  }

  /* ---------- add costume to selected (prefer VM/GUI) ---------- */
  async function addCostumeToSelected(name, md5ext){
    const vm = window.vm || await bindVM(6000), GUI = window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const t = vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
    if(!t) throw new Error('No editing target');

    const asset = await fetchAsset(md5ext);
    const isSVG = asset.isSVG;

    // GUI helper if present
    if (GUI?.handleCostumeUpload) {
      try{
        await GUI.handleCostumeUpload(asset.blob, isSVG?'image/svg+xml':'image/png', t.id);
        __sascTag('costume','success via GUI.handleCostumeUpload');
        return;
      }catch(e){ __sascTag('costume','GUI helper failed: '+(e&&e.message||e)); }
    }

    // VM helper if present
    if (typeof vm.addCostume === 'function') {
      try{
        const model = costumeFromMd5(name, md5ext);
        await vm.addCostume(model, t.id);
        // Ensure bytes exist for thumbnail/renderer
        await applyCostumeToTarget(vm, t, md5ext, asset, {replaceAll:false, name});
        __sascTag('costume','success via vm.addCostume (+bytes)');
        return;
      }catch(e){ __sascTag('costume','vm.addCostume failed: '+(e&&e.message||e)); }
    }

    // Manual, guaranteed
    await applyCostumeToTarget(vm, t, md5ext, asset, {replaceAll:false, name});
    __sascTag('costume','success via manual injection');
  }

  /* ---------- add backdrop (prefer GUI/VM; manual fallback) ---------- */
  async function addBackdropSmart(name, md5ext){
    const vm = window.vm || await bindVM(6000), GUI = window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const asset = await fetchAsset(md5ext);
    const isSVG = asset.isSVG;

    // make sure Stage is the editing target for some helpers
    const stage = vm.runtime.getTargetForStage?.();
    if (stage && typeof vm.setEditingTarget === 'function') {
      try{ vm.setEditingTarget(stage.id); }catch(_){}
    }

    if (GUI?.handleBackdropUpload) {
      try{
        await GUI.handleBackdropUpload(asset.blob, isSVG?'image/svg+xml':'image/png');
        __sascTag('backdrop','success via GUI.handleBackdropUpload');
        return;
      }catch(e){ __sascTag('backdrop','GUI helper failed: '+(e&&e.message||e)); }
    }

    if (typeof vm.addBackdrop === 'function') {
      try{
        const model = costumeFromMd5(name, md5ext);
        await vm.addBackdrop(md5ext, model);
        // Ensure bytes exist
        await applyCostumeToTarget(vm, stage, md5ext, asset, {replaceAll:false, name});
        __sascTag('backdrop','success via vm.addBackdrop (+bytes)');
        return;
      }catch(e){ __sascTag('backdrop','vm.addBackdrop failed: '+(e&&e.message||e)); }
    }

    // Manual Stage injection
    if (!stage) throw new Error('No stage target');
    await applyCostumeToTarget(vm, stage, md5ext, asset, {replaceAll:false, name});
    __sascTag('backdrop','success via manual stage injection');
  }

  /* ---------- sounds ---------- */
  async function addSoundToSelected(name, md5ext){
    const vm=window.vm || await bindVM(6000), GUI=window.GUI;
    if(!vm?.runtime) throw new Error('vm missing');
    const t = vm.runtime.getEditingTarget?.() || vm.runtime.getTargetForStage?.();
    if(!t) throw new Error('No editing target');
    const asset=await fetchAsset(md5ext);
    if(GUI?.handleSoundUpload){
      try{ await GUI.handleSoundUpload(asset.blob, t.id); __sascTag('sound','success via GUI.handleSoundUpload'); return; }
      catch(e){ __sascTag('sound','GUI helper failed: '+(e&&e.message||e)); }
    }
    if(typeof vm.addSound==='function'){
      try{
        const id = md5ext.slice(0,32);
        const ext = md5ext.split('.').pop().toLowerCase();
        const snd={ name:name||('Sound '+md5ext.slice(0,6)), assetId:id, md5ext, dataFormat:ext, format:'', rate:44100, sampleCount:0 };
        await vm.addSound(md5ext, snd, t.id); __sascTag('sound','success via vm.addSound'); return;
      }catch(e){ __sascTag('sound','vm.addSound failed: '+(e&&e.message||e)); }
    }
    throw new Error('No sound upload path available in this build');
  }

  /* ---------- wire buttons ---------- */
  document.getElementById('btn-targets').onclick=()=>{
    const vm=window.vm; if(!vm||!vm.runtime) return __sascTag('targets','VM not ready');
    const ts=vm.runtime.targets||[]; __sascLog('[targets] '+ts.length+' targets');
    ts.forEach(t=>__sascLog('- ['+(t.isStage?'STAGE':'SPRITE')+'] '+(t.getName?t.getName():t.sprite?.name||'(?)')));
  };
  document.getElementById('btn-apple').onclick=()=>addSpriteFromCostume('Apple','3826a4091a33e4d26f87a2fac7cf796b.svg').catch(e=>__sascTag('tools','apple failed: '+(e&&e.message||e)));
  document.getElementById('btn-backdrop').onclick=()=>{
    const md5ext=prompt('Backdrop md5.ext (svg/png):','e7c147730f19d284bcd7b3f00af19bb6.svg'); if(!md5ext) return;
    addBackdropSmart('Backdrop '+md5ext.slice(0,6), md5ext.trim()).catch(e=>__sascTag('tools','add backdrop failed: '+(e&&e.message||e)));
  };
  document.getElementById('btn-costume').onclick=()=>{
    const md5ext=prompt('Costume md5.ext (svg/png):','3826a4091a33e4d26f87a2fac7cf796b.svg'); if(!md5ext) return;
    addCostumeToSelected('Costume '+md5ext.slice(0,6), md5ext.trim()).catch(e=>__sascTag('tools','add costume failed: '+(e&&e.message||e)));
  };
  document.getElementById('btn-sound').onclick=()=>{
    const md5ext=prompt('Sound md5.ext (wav/mp3):','0b1e3033140d094563248e61de4039e5.wav'); if(!md5ext) return;
    addSoundToSelected('Sound '+md5ext.slice(0,6), md5ext.trim()).catch(e=>__sascTag('tools','add sound failed: '+(e&&e.message||e)));
  };

  // bind after mount
  (window.bindVM||(()=>Promise.resolve(null)))(20000);
</script>
</body>
</html>
