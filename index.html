<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (vm-zip-inject)</title>
  <link rel="icon" href="./favicon.ico"/>

  <style>
    html,body,#app{height:100%;margin:0}
    #app{display:flex;align-items:stretch;justify-content:stretch;background:#0b1120}
    #sasc-console{position:fixed;left:10px;bottom:10px;width:360px;max-height:60vh;background:#111a;backdrop-filter:blur(2px);
      color:#0ff;font:12px/1.35 ui-monospace,Consolas,monospace;border:1px solid #044;border-radius:8px;z-index:9999}
    #sasc-console header{display:flex;gap:6px;flex-wrap:wrap;justify-content:space-between;align-items:center;padding:6px 8px;background:#022;border-bottom:1px solid #044;border-radius:8px 8px 0 0}
    #sasc-console pre{margin:0;padding:6px 8px;white-space:pre-wrap;overflow:auto;max-height:calc(60vh - 80px)}
    #sasc-console button{all:unset;cursor:pointer;color:#0ff;padding:2px 6px;border:1px solid #044;border-radius:6px}
    #sasc-console .btnrow{display:flex;gap:6px;flex-wrap:wrap}
  </style>

  <!-- CSS loader; if manifest 404s, we rely on shim -->
  <script>
  (function loadScratchGuiCSS(){
    var ORIGIN='https://scratchfoundation.github.io', BASE=ORIGIN+'/scratch-gui';
    function add(h){var l=document.createElement('link');l.rel='stylesheet';l.href=h;document.head.appendChild(l);}
    if(document.documentElement.hasAttribute('data-sasc-css-loaded')) return;
    document.documentElement.setAttribute('data-sasc-css-loaded','1');
    fetch(BASE+'/asset-manifest.json')
      .then(r=>r.ok?r.json():Promise.reject())
      .then(man=>{
        var files=(man&&man.files)||{}, css=[];
        Object.keys(files).forEach(k=>{ if(/\.css$/.test(files[k])) css.push(files[k]); });
        css = Array.from(new Set(css));
        css.forEach(p=>{
          var href = p.startsWith('http') ? p : (p.startsWith('/') ? ORIGIN+p : BASE+'/'+p.replace(/^\.?\//,''));
          add(href);
        });
        console.log('[SASC] CSS via manifest:', css);
      })
      .catch(()=>{ console.warn('[SASC] demo CSS manifest not available; using shim'); });
  })();
  </script>

  <!-- Shim that keeps modal/tiles clickable and fixes stacking -->
  <style id="sasc-css-shim">
    [class*="gui-body"]{display:flex;min-height:100vh}
    [class*="blocks"],[class*="blockly"]{min-width:280px;flex:1 1 50%}
    [class*="target-pane"]{min-width:240px;flex:0 0 240px}
    [class*="stage-wrapper"]{flex:0 0 auto;position:relative;z-index:0}
    [class*="stage-header"]{position:relative;z-index:2}
    [class*="green-flag"],[class*="stop-all"]{position:relative;z-index:3}
    canvas{cursor:default}
    [class*="react-modal"], [class*="modal-content"], [class*="modal-overlay"]{position:relative;z-index:10000}
    [class*="library-item"], [class*="library-item"] * {pointer-events:auto !important; cursor:pointer}
    [class*="sprite-selector_add-button"], [class*="stage-selector_add-button"]{pointer-events:auto}
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- SASC console -->
  <div id="sasc-console">
    <header>
      <strong>SASC</strong>
      <div class="btnrow">
        <button onclick="(document.querySelector('#sasc-console pre').textContent='SASC clear\n')">Clear</button>
        <button id="btn-scan-vm">Scan VM</button>
        <button id="btn-list-targets">List targets</button>
        <button id="btn-test-apple">Test Apple asset</button>
        <button id="btn-test-sky">Test Sky asset</button>
        <button id="btn-libs">Test libraries</button>
        <button id="btn-add-apple-zip">Add Apple sprite (zip)</button>
        <button id="btn-add-sky-zip">Add Blue Sky sprite (zip)</button>
      </div>
    </header>
    <pre>SASC clear
</pre>
  </div>
  <script>
    (function(){
      const pre = document.querySelector('#sasc-console pre');
      window.__sascLog = (m)=>{ try{ pre.textContent += m+'\n'; pre.scrollTop = pre.scrollHeight; }catch(_){} console.log(m); };
      window.addEventListener('click', e => __sascLog('[Click] ' + e.target.tagName));
      window.addEventListener('unhandledrejection', e => __sascLog('[unhandledrejection]: ' + (e.reason && (e.reason.stack || e.reason))));
    })();
  </script>

  <!-- React UMDs -->
  <script src="https://unpkg.com/react@16.14.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@16.14.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>

  <script>
    (function(){
      if (window.React && !window.react)      { window.react = window.React;      console.log('[SASC] react alias set');}
      if (window.ReactDOM && !window['react-dom']) { window['react-dom'] = window.ReactDOM; console.log('[SASC] react-dom alias set');}
      if (window.Redux && !window.redux)      { window.redux = window.Redux;      console.log('[SASC] redux alias set');}
      console.log('[SASC] href:', location.href);
      console.log('[SASC] React present:', !!window.React, 'version:', window.React && window.React.version);
      console.log('[SASC] ReactDOM present:', !!window.ReactDOM);
      console.log('[SASC] Redux present:', !!window.Redux);
    })();
  </script>

  <!-- FETCH-only asset hook (no XHR patch) + diagnostics -->
  <script>
  (function(){
    const base = location.pathname.replace(/\/[^/]*$/, '/'); // /<user>/<repo>/
    const repoRoot = base.replace(/\/$/, '');
    const toLocalAsset = (u) => {
      const m = u && u.match(/internalapi\/asset\/([a-f0-9]{32}\.(?:sprite3|json|svg|png|gif|jpg|wav|mp3))\/get\/?/i);
      return m ? (repoRoot + '/static/assets/' + m[1]) : null;
    };
    const f = window.fetch;
    window.fetch = async function(input, init){
      const url = (typeof input === 'string') ? input : (input && input.url);
      const local = toLocalAsset(url);
      if (local){
        try {
          const r = await f(local, init);
          console.log('[ASSET fetch try local]', local);
          if (r && r.ok) { console.log('[ASSET fetch OK local]', r.status, local); return r; }
          console.log('[ASSET fetch MISS local → CDN]', r && r.status, url);
        } catch (e) { console.log('[ASSET fetch local error → CDN]', e); }
      }
      const r2 = await f.apply(this, arguments);
      if (url && /internalapi\/asset\//i.test(url)) {
        console.log('[ASSET fetch CDN result]', r2.status, r2.url);
      }
      return r2;
    };
    console.log('[hooks] installed (assets local-first; **no XHR patch**)');
  })();
  </script>

  <!-- GUI bundle -->
  <script src="scratch-gui.js?v=stable-boot-clean-index"></script>

  <!-- JSZip for sprite3 creation -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" crossorigin="anonymous"></script>

  <!-- Boot + VM finder + sprite3 injectors -->
  <script>
  (function boot(){
    const log = m => (window.__sascLog ? __sascLog(m) : console.log('[SASC]', m));

    function findVMViaFiber(){
      try{
        const app = document.getElementById('app');
        const root = app && app._reactRootContainer && app._reactRootContainer._internalRoot && app._reactRootContainer._internalRoot.current;
        if (!root) return null;
        let found = null;
        const seen = new Set(); const stack=[root];
        while (stack.length){
          const n = stack.pop();
          if (!n || seen.has(n)) continue;
          seen.add(n);
          const cands = [];
          if (n.memoizedProps) cands.push(n.memoizedProps);
          if (n.stateNode && n.stateNode.props) cands.push(n.stateNode.props);
          for (const p of cands){
            if (p && p.vm && p.vm.runtime && typeof p.vm.greenFlag === 'function'){ found = p.vm; break; }
          }
          if (found) break;
          if (n.child) stack.push(n.child);
          if (n.sibling) stack.push(n.sibling);
        }
        return found;
      }catch(_){ return null; }
    }
    function exposeVM(){
      const vm = window.vm || findVMViaFiber();
      if (vm && vm.runtime) { window.vm = vm; log('VM exposed on window.vm (targets='+vm.runtime.targets.length+')'); return vm; }
      log('[doctor] VM not detected (yet)'); return null;
    }

    // Mount GUI
    try {
      const app = document.getElementById('app');
      const GUI = window.GUI;
      if (!GUI) { log('ERROR: window.GUI missing'); return; }
      if (typeof GUI.setAppElement === 'function') GUI.setAppElement(app);
      if (typeof GUI.render === 'function') {
        GUI.render(app);
        log('GUI mounted via GUI.render(app)');
      } else {
        let Wrapped = GUI.default || GUI.GUI || GUI;
        if (typeof GUI.AppStateHOC === 'function') Wrapped = GUI.AppStateHOC(Wrapped);
        if (typeof GUI.ProjectLoaderHOC === 'function') Wrapped = GUI.ProjectLoaderHOC(Wrapped);
        if (typeof GUI.HashParserHOC === 'function') Wrapped = GUI.HashParserHOC(Wrapped);
        const props = { isPlayerOnly:false, isFullScreen:false, canUseCloud:false, projectId:(location.hash&&/\d+/.test(location.hash))?undefined:'0' };
        const el = window.React.createElement(Wrapped, props);
        window.ReactDOM.render(el, app);
        log('GUI mounted via HashParser(ProjectLoader(AppState(GUI))) with projectId=' + (props.projectId || 'hash'));
      }
    } catch (e) { (window.__sascLog||console.error)('BOOT ERROR: ' + (e && e.stack || e)); return; }

    // Poll for VM
    let waited = 0;
    const tick = setInterval(() => {
      const vm = exposeVM();
      if (vm) { clearInterval(tick); }
      else if ((waited += 500) > 30000) { log('[doctor] VM not found after 30s'); clearInterval(tick); }
    }, 500);

    // Diagnostic helpers
    async function testAsset(md5ext){
      const base = location.pathname.replace(/\/[^/]*$/, '/').replace(/\/$/, '');
      const local = base + '/static/assets/' + md5ext;
      const cdn   = 'https://assets.scratch.mit.edu/internalapi/asset/' + md5ext + '/get/';
      try{ const r = await fetch(local,{cache:'no-store'}); log('[test asset] local '+md5ext+' → '+r.status); }catch(e){ log('[test asset] local error '+md5ext+' → '+e); }
      try{ const r = await fetch(cdn,{cache:'no-store'}); log('[test asset] cdn   '+md5ext+' → '+r.status); }catch(e){ log('[test asset] cdn error '+md5ext+' → '+e); }
    }
    async function testLibraries(){
      try{ const r1=await fetch('libraries/sprites.json',{cache:'no-store'}); log('[libs] sprites.json → '+r1.status);
            const r2=await fetch('libraries/backdrops.json',{cache:'no-store'}); log('[libs] backdrops.json → '+r2.status);
      }catch(e){ log('[libs] error: '+e); }
    }
    function listTargets(){
      const vm = window.vm || null;
      if (!vm || !vm.runtime) { log('[targets] VM not ready'); return; }
      const names = vm.runtime.targets.map(t => (t.isStage?'[STAGE] ':'[SPRITE] ')+ (t.getName?t.getName():t.sprite && t.sprite.name || '(unnamed)'));
      log('[targets] '+names.length+' targets\n- ' + names.join('\n- '));
    }

    // Build a minimal sprite.json structure for a single-costume sprite
    function makeSpriteJSON(name, md5ext){
      return {
        name,
        isStage: false,
        variables: {},
        lists: {},
        broadcasts: {},
        blocks: {},
        comments: {},
        currentCostume: 0,
        costumes: [{
          name,
          md5ext,
          dataFormat: md5ext.toLowerCase().endsWith('.svg') ? 'svg' : 'png',
          rotationCenterX: 0,
          rotationCenterY: 0
        }],
        sounds: [],
        volume: 100,
        layerOrder: 1,
        visible: true,
        x: 0, y: 0, size: 100, direction: 90, draggable: false,
        rotationStyle: "all around"
      };
    }

    // Create a .sprite3 zip in-browser and feed it to vm.addSprite
    async function addSpriteViaZip(spriteName, md5ext){
      try{
        const vm = window.vm;
        if (!vm || !vm.addSprite) throw new Error('vm.addSprite not available');

        // fetch the actual asset so zip contains the costume payload file
        const assetURL = 'static/assets/' + md5ext;
        const resp = await fetch(assetURL, {cache:'no-store'});
        if (!resp.ok) throw new Error('asset fetch ' + resp.status + ' for ' + md5ext);
        const assetBuf = await resp.arrayBuffer();

        const spriteJSON = makeSpriteJSON(spriteName, md5ext);
        const zip = new JSZip();
        zip.file('sprite.json', JSON.stringify(spriteJSON, null, 2));
        zip.file(md5ext, assetBuf); // include costume payload with exact md5.ext filename

        const u8 = await zip.generateAsync({type:'uint8array', compression:'STORE'});
        await vm.addSprite(u8);
        log('[inject] sprite added via vm.addSprite: ' + spriteName + ' ('+md5ext+')');
        listTargets();
      } catch(e){
        log('[inject] failed to add sprite "'+spriteName+'": '+(e && e.message));
      }
    }

    // Wire buttons
    document.getElementById('btn-scan-vm').onclick = exposeVM;
    document.getElementById('btn-list-targets').onclick = listTargets;
    document.getElementById('btn-test-apple').onclick = () => testAsset('3826a4091a33e4d26f87a2fac7cf796b.svg');
    document.getElementById('btn-test-sky').onclick = () => testAsset('e7c147730f19d284bcd7b3f00af19bb6.svg');
    document.getElementById('btn-libs').onclick = testLibraries;

    document.getElementById('btn-add-apple-zip').onclick = () =>
      addSpriteViaZip('Apple', '3826a4091a33e4d26f87a2fac7cf796b.svg');

    document.getElementById('btn-add-sky-zip').onclick = () =>
      addSpriteViaZip('Blue Sky', 'e7c147730f19d284bcd7b3f00af19bb6.svg'); // as a sprite (backdrop fallback)
  })();
  </script>
</body>
</html>
