<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>SASC Scratch Editor — index (clean + selective rewrite)</title>
  <link rel="icon" href="./favicon.ico"/>

  <style>
    html,body,#app{height:100%;margin:0}
    #app{display:flex;align-items:stretch;justify-content:stretch;background:#0b1120}

    /* SASC console overlay */
    #sasc-console{position:fixed;left:10px;bottom:10px;width:320px;max-height:45vh;background:#111a;backdrop-filter:blur(2px);
      color:#0ff;font:12px/1.35 ui-monospace,Consolas,monospace;border:1px solid #044;border-radius:8px;z-index:99999}
    #sasc-console header{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;background:#022;border-bottom:1px solid #044;border-radius:8px 8px 0 0}
    #sasc-console pre{margin:0;padding:6px 8px;white-space:pre-wrap;overflow:auto;max-height:calc(45vh - 32px)}
    #sasc-console button{all:unset;cursor:pointer;color:#0ff;padding:2px 6px;border:1px solid #044;border-radius:6px}
  </style>

  <!-- Try to load GUI CSS from the demo site; if it 404s, fall back to our shim -->
  <script>
  (function loadScratchGuiCSS(){
    var ORIGIN='https://scratchfoundation.github.io', BASE=ORIGIN+'/scratch-gui';
    function add(h){var l=document.createElement('link');l.rel='stylesheet';l.href=h;document.head.appendChild(l);}
    function abs(p){if(!p)return null; if(p.startsWith('http'))return p; if(p.startsWith('//'))return 'https:'+p; if(p.startsWith('/'))return ORIGIN+p; return BASE+'/'+p.replace(/^\.?\//,'');}
    if(document.documentElement.hasAttribute('data-sasc-css-loaded')) return;
    document.documentElement.setAttribute('data-sasc-css-loaded','1');
    fetch(BASE+'/asset-manifest.json')
      .then(r=>r.ok?r.json():Promise.reject())
      .then(man=>{
        var files=(man&&man.files)||{}, css=[];
        Object.keys(files).forEach(k=>{if(/\.css$/.test(files[k])) css.push(files[k]);});
        if (Array.isArray(man.entrypoints)) man.entrypoints.forEach(ep=>{if(/\.css$/.test(ep)) css.push(ep);});
        css=Array.from(new Set(css)).map(abs); css.forEach(add);
        console.log('[SASC] CSS via manifest:', css);
      })
      .catch(()=>{console.warn('[SASC] demo CSS manifest not available; using shim');});
  })();
  </script>

  <!-- Minimal CSS shim so layout is sane even if external CSS changes -->
  <style id="sasc-css-shim">
    [class*="stage-wrapper"]{position:relative;z-index:0}
    [class*="stage-header"]{position:relative;z-index:2}
    [class*="green-flag"],[class*="stop-all"]{position:relative;z-index:3}
    canvas{cursor:default}
    [class*="gui-body"]{display:flex;min-height:100vh}
    [class*="blockly"],[class*="blocks"]{min-width:280px;flex:1 1 50%}
    [class*="target-pane"]{min-width:240px;flex:0 0 240px}
    [class*="stage-wrapper"]{flex:0 0 auto}
    [class*="react-modal"],[class*="modal-content"]{z-index:9999;position:relative}
    [class*="sprite-selector"] img{display:block}
    [class*="sprite-selector_add-button"], [class*="stage-selector_add-button"]{pointer-events:auto}
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- SASC console -->
  <div id="sasc-console">
    <header>
      <strong>SASC</strong>
      <div><button onclick="(document.querySelector('#sasc-console pre').textContent='SASC clear\n')">Clear</button></div>
    </header>
    <pre>SASC clear
</pre>
  </div>
  <script>
    (function(){
      const pre = document.querySelector('#sasc-console pre');
      window.__sascLog = (m)=>{ try{ pre.textContent += m+'\n'; pre.scrollTop = pre.scrollHeight; }catch(_){} console.log(m); };
      window.addEventListener('click', e => __sascLog('[Click] ' + e.target.tagName));
      window.addEventListener('unhandledrejection', e => __sascLog('[unhandledrejection]: ' + (e.reason && (e.reason.stack || e.reason))));
    })();
  </script>

  <!-- React UMDs -->
  <script src="https://unpkg.com/react@16.14.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@16.14.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/redux@4.2.1/dist/redux.min.js"></script>
  <script>
    (function(){
      if (window.React && !window.react)      { window.react = window.React;      console.log('[SASC] react alias set');}
      if (window.ReactDOM && !window['react-dom']) { window['react-dom'] = window.ReactDOM; console.log('[SASC] react-dom alias set');}
      if (window.Redux && !window.redux)      { window.redux = window.Redux;      console.log('[SASC] redux alias set');}
      console.log('[SASC] href:', location.href);
      console.log('[SASC] React present:', !!window.React, 'version:', window.React && window.React.version);
      console.log('[SASC] ReactDOM present:', !!window.ReactDOM);
      console.log('[SASC] Redux present:', !!window.Redux);
    })();
  </script>

  <!-- Selective local-first asset hooks (media only, NOT .sprite3/.json) with fallback -->
  <script>
  (function(){
    const base = location.pathname.replace(/\/[^/]*$/, '/'); // /<user>/<repo>/
    const repoRoot = base.replace(/\/$/, '');
    const MEDIA_EXTS = /(?:svg|png|gif|jpe?g|mp3|wav)$/i; // what we actually mirror
    function toLocalAsset(u){
      if (!u) return null;
      const m = u.match(/internalapi\/asset\/([a-f0-9]{32})\.(\w+)\/get\/?/i);
      if (!m) return null;
      const ext = m[2];
      if (!MEDIA_EXTS.test(ext)) return null; // DO NOT rewrite sprite3/json
      return repoRoot + '/static/assets/' + m[1] + '.' + ext;
    }

    // fetch: try local, then original
    const f = window.fetch;
    window.fetch = async function(input, init){
      const url = (typeof input === 'string') ? input : (input && input.url);
      const local = toLocalAsset(url);
      if (local){
        try {
          const r = await f(local, init);
          if (r && r.ok) { console.log('[SASC] fetch local OK →', local); return r; }
          console.log('[SASC] fetch local not OK ('+(r && r.status)+') → falling back:', url);
        } catch (e) { console.log('[SASC] fetch local error → falling back:', e); }
      }
      return f.apply(this, arguments);
    };

    // XHR: try local; if not 2xx, retry original
    const XO = window.XMLHttpRequest;
    window.XMLHttpRequest = function(){
      const x = new XO();
      let original = null, method = 'GET';
      const _open = x.open;
      x.open = function(m,u){
        method = m; original = u;
        const local = (typeof u === 'string') ? toLocalAsset(u) : null;
        if (local){
          _open.call(x, m, local);
          const onload = function(){
            if (x.status >= 200 && x.status < 300) {
              console.log('[SASC] xhr local OK →', local);
            } else {
              console.log('[SASC] xhr local not OK ('+x.status+') → retry ORIGINAL:', original);
              x.removeEventListener('load', onload);
              _open.call(x, method, original);
              x.send(); // assets are GET
            }
          };
          x.addEventListener('load', onload);
          return;
        }
        return _open.apply(x, arguments);
      };
      const _send = x.send; x.send = function(){ return _send.apply(x, arguments); };
      return x;
    };
    console.log('[hooks] installed (assets local-first for media only; CDN for sprite3/json)');
  })();
  </script>

  <!-- Your GUI bundle -->
  <script src="scratch-gui.js?v=stable-boot-clean-index"></script>
<script>
(function bindVM(){
  const log = (m)=> (window.__sascLog ? __sascLog(m) : console.log('[bind]', m));
  let waited = 0;
  const grab = () => {
    const GUI = window.GUI || {};
    return window.vm || GUI.vm || (typeof GUI.getVm === 'function' ? GUI.getVm() : null);
  };
  const t = setInterval(()=>{
    const vm = grab();
    if (vm && vm.runtime && vm.runtime.targets) {
      window.vm = vm;
      log('window.vm attached (targets='+vm.runtime.targets.length+')');
      clearInterval(t);
      return;
    }
    if ((waited += 250) > 15000) {
      clearInterval(t);
      log('could not attach vm (15s)');
    }
  }, 250);
})();
</script>

  <!-- Robust boot + default projectId=0 -->
  <script>
  (function boot(){
    const log = m => (window.__sascLog ? __sascLog(m) : console.log('[SASC]', m));
    try {
      const app = document.getElementById('app');
      const GUI = window.GUI;
      if (!GUI) { log('ERROR: window.GUI missing'); return; }
      if (typeof GUI.setAppElement === 'function') GUI.setAppElement(app);

      if (typeof GUI.render === 'function') { GUI.render(app); log('GUI mounted via GUI.render(app)'); }
      else {
        let Wrapped = GUI.default || GUI.GUI || GUI;
        if (typeof GUI.AppStateHOC === 'function') Wrapped = GUI.AppStateHOC(Wrapped);
        if (typeof GUI.ProjectLoaderHOC === 'function') Wrapped = GUI.ProjectLoaderHOC(Wrapped);
        if (typeof GUI.HashParserHOC === 'function') Wrapped = GUI.HashParserHOC(Wrapped);
        const props = { isPlayerOnly:false, isFullScreen:false, canUseCloud:false, projectId:(location.hash&&/\d+/.test(location.hash))?undefined:'0' };
        const el = window.React.createElement(Wrapped, props);
        window.ReactDOM.render(el, app);
        log('GUI mounted via HashParser(ProjectLoader(AppState(GUI))) with projectId=' + (props.projectId || 'hash'));
      }

      // Light VM ready ping
      let waited = 0;
      const tick = setInterval(() => {
        const vm = window.vm || (window.GUI && window.GUI.vm);
        if (vm && vm.runtime && vm.runtime.targets) {
          log('VM exposed on window.vm (targets=' + vm.runtime.targets.length + ')');
          clearInterval(tick);
        }
        if ((waited += 250) > 15000) { clearInterval(tick); log('VM not found after 15s'); }
      }, 250);
    } catch (e) { (window.__sascLog||console.error)('BOOT ERROR: ' + (e.stack || e)); }
  })();
  </script>

  <!-- SASC asset tools (backdrop, costume, sound) — robust, multi-strategy -->
  <script>
  /* SASC asset tools (backdrop, costume, sound) — robust, multi-strategy */
  (function(){
    const log = (m)=> (window.__sascLog ? __sascLog(m) : console.log('[SASC]', m));
    const warn = (m)=> (window.__sascLog ? __sascLog(m) : console.warn('[SASC]', m));

    function ensureButtons(){
      const header = document.querySelector('#sasc-console header');
      if (!header) return;
      if (!document.getElementById('btn-add-sky-backdrop')) {
        const wrap = document.createElement('span'); wrap.style.marginLeft = '8px';
        wrap.innerHTML = [
          '<button id="btn-add-sky-backdrop">Add Blue Sky as Backdrop</button>',
          '<button id="btn-add-backdrop-prompt" style="margin-left:4px">Add Backdrop (md5.ext)…</button>',
          '<button id="btn-add-costume-prompt" style="margin-left:4px">Add Costume to Selected…</button>',
          '<button id="btn-add-sound-prompt" style="margin-left:4px">Add Sound to Selected…</button>'
        ].join(' ');
        wrap.className = 'btnrow';
        header.appendChild(wrap);
      }
    }
    ensureButtons();

    function repoBase(){ return location.pathname.replace(/\/[^/]*$/, '/').replace(/\/$/, ''); }
    function parseAsset(md5ext){ const m=String(md5ext||'').match(/^([a-f0-9]{32})\.(\w+)$/i); return m?{assetId:m[1],ext:m[2].toLowerCase()}:null; }
    function stage(vm){ return vm && vm.runtime && vm.runtime.getTargetForStage ? vm.runtime.getTargetForStage() : null; }
    function selected(vm){
      if (!vm || !vm.runtime) return null;
      const t = vm.runtime.getEditingTarget && vm.runtime.getEditingTarget();
      return t || stage(vm);
    }
    function costumeObj(name, md5ext){
      const p = parseAsset(md5ext)||{ext:'png',assetId:''};
      return {
        name: name || ('Costume ' + md5ext.slice(0,6)),
        assetId: p.assetId,
        md5ext,
        dataFormat: (p.ext==='svg'?'svg':p.ext),
        rotationCenterX: 240, rotationCenterY: 180
      };
    }
    function soundObj(name, md5ext, sampleRate){
      const p = parseAsset(md5ext)||{assetId:'',ext:'wav'};
      return {
        name: name || ('Sound ' + md5ext.slice(0,6)),
        assetId: p.assetId,
        md5ext,
        dataFormat: (p.ext==='wav'?'wav':p.ext),
        format: '',
        rate: sampleRate || 44100,
        sampleCount: 0
      };
    }

    async function fetchAsset(md5ext){
      const local = repoBase() + '/static/assets/' + md5ext;
      try {
        const r = await fetch(local, {cache:'no-store'});
        if (r.ok) {
          const arr = await r.arrayBuffer();
          const p = parseAsset(md5ext);
          const mime = p && p.ext==='svg' ? 'image/svg+xml'
                    : p && (p.ext==='png'||p.ext==='jpg'||p.ext==='jpeg'||p.ext==='gif') ? ('image/'+(p.ext==='jpg'?'jpeg':p.ext))
                    : p && (p.ext==='wav'||p.ext==='mp3') ? ('audio/'+p.ext)
                    : 'application/octet-stream';
          return { arrayBuffer: arr, blob: new Blob([arr], {type:mime}), mime };
        }
        warn('[asset] local ' + md5ext + ' not OK: ' + r.status);
      } catch(e){ warn('[asset] local fetch failed: ' + e); }

      const cdn = 'https://assets.scratch.mit.edu/internalapi/asset/'+ md5ext +'/get/';
      const r2 = await fetch(cdn, {cache:'no-store'});
      if (!r2.ok) throw new Error('CDN fetch '+r2.status);
      const arr = await r2.arrayBuffer();
      const p = parseAsset(md5ext);
      const mime = p && p.ext==='svg' ? 'image/svg+xml'
                : p && (p.ext==='png'||p.ext==='jpg'||p.ext==='jpeg'||p.ext==='gif') ? ('image/'+(p.ext==='jpg'?'jpeg':p.ext))
                : p && (p.ext==='wav'||p.ext==='mp3') ? ('audio/'+p.ext)
                : 'application/octet-stream';
      return { arrayBuffer: arr, blob: new Blob([arr], {type:mime}), mime };
    }

    async function addBackdropSmart(name, md5ext){
      const vm = window.vm, GUI = window.GUI;
      if (!vm) throw new Error('vm missing');
      const asset = await fetchAsset(md5ext);
      const isSVG = /\.svg$/i.test(md5ext);
      const cos = costumeObj(name, md5ext);

      if (GUI && typeof GUI.handleBackdropUpload === 'function'){
        try { log('[backdrop] trying GUI.handleBackdropUpload');
          await GUI.handleBackdropUpload(asset.blob, isSVG ? 'image/svg+xml' : 'image/png');
          log('[backdrop] success via GUI.handleBackdropUpload'); return;
        } catch(e){ warn('[backdrop] GUI.handleBackdropUpload failed: ' + (e&&e.message||e)); }
      } else { log('[backdrop] GUI.handleBackdropUpload not available'); }

      if (typeof vm.addBackdrop === 'function'){
        try { log('[backdrop] trying vm.addBackdrop'); await vm.addBackdrop(md5ext, cos);
          log('[backdrop] success via vm.addBackdrop'); return;
        } catch(e){ warn('[backdrop] vm.addBackdrop failed: ' + (e&&e.message||e)); }
      } else { log('[backdrop] vm.addBackdrop not available'); }

      const st = stage(vm);
      if (!st) throw new Error('No stage target');
      if (typeof vm.addCostume === 'function'){
        try { log('[backdrop] trying vm.addCostume(costume, stage.id)'); await vm.addCostume(cos, st.id);
          log('[backdrop] success via vm.addCostume(costume, stage.id)'); return;
        } catch(e1){ warn('[backdrop] signature A failed: ' + (e1&&e1.message||e1));
          try { log('[backdrop] trying vm.addCostume(md5ext, costume, stage.id)'); await vm.addCostume(md5ext, cos, st.id);
            log('[backdrop] success via vm.addCostume(md5ext, costume, stage.id)'); return;
          } catch(e2){ warn('[backdrop] signature B failed: ' + (e2&&e2.message||e2)); }
        }
      } else { log('[backdrop] vm.addCostume not available'); }

      try {
        log('[backdrop] manual Stage injection');
        const storage = vm.runtime && vm.runtime.storage;
        if (!storage) throw new Error('No VM storage');
        const p = parseAsset(md5ext)||{ext:'svg', assetId:''};
        const type = (p.ext==='svg') ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
        storage.createAsset(type, p.ext, new Uint8Array(asset.arrayBuffer), p.assetId);

        st.sprite.costumes.push(cos);
        const idx = st.sprite.costumes.length - 1;

        if (vm.renderer) {
          if (isSVG && vm.renderer.createSVGSkin) {
            const text = await asset.blob.text();
            const skinId = vm.renderer.createSVGSkin(text);
            st.setCostume(idx);
            vm.renderer.updateDrawableProperties(st.drawableID, { skinId });
          } else if (!isSVG && vm.renderer.createBitmapSkin) {
            const bmp = await createImageBitmap(asset.blob);
            const skinId = vm.renderer.createBitmapSkin(bmp, 1);
            st.setCostume(idx);
            vm.renderer.updateDrawableProperties(st.drawableID, { skinId });
          } else {
            st.setCostume(idx);
          }
        } else {
          st.setCostume(idx);
        }

        try { vm.runtime.emit('PROJECT_CHANGED'); } catch(_){}
        log('[backdrop] success via manual injection (index '+idx+')');
        return;
      } catch(e){ warn('[backdrop] manual injection failed: ' + (e&&e.message||e)); }

      throw new Error('All backdrop strategies failed');
    }

    async function addCostumeToSelectedSmart(name, md5ext){
      const vm = window.vm, GUI = window.GUI;
      if (!vm) throw new Error('vm missing');
      const t = (vm.runtime && vm.runtime.getEditingTarget && vm.runtime.getEditingTarget()) || (vm.runtime && vm.runtime.getTargetForStage && vm.runtime.getTargetForStage());
      if (!t) throw new Error('No editing target (select a sprite or the stage)');
      const asset = await fetchAsset(md5ext);
      const isSVG = /\.svg$/i.test(md5ext);
      const cos = costumeObj(name, md5ext);

      if (GUI && typeof GUI.handleCostumeUpload === 'function'){
        try { log('[costume] GUI.handleCostumeUpload'); await GUI.handleCostumeUpload(asset.blob, isSVG ? 'image/svg+xml' : 'image/png', t.id);
          log('[costume] success via GUI.handleCostumeUpload'); return;
        } catch(e){ warn('[costume] GUI.handleCostumeUpload failed: ' + (e&&e.message||e)); }
      }

      if (typeof vm.addCostume === 'function'){
        try { await vm.addCostume(cos, t.id); log('[costume] success via vm.addCostume(costume, target)'); return; }
        catch(e1){
          warn('[costume] signature A failed: '+(e1&&e1.message||e1));
          try { await vm.addCostume(md5ext, cos, t.id); log('[costume] success via vm.addCostume(md5ext, costume, target)'); return; }
          catch(e2){ warn('[costume] signature B failed: '+(e2&&e2.message||e2)); }
        }
      } else { log('[costume] vm.addCostume not available'); }

      try {
        const storage = vm.runtime && vm.runtime.storage;
        if (!storage) throw new Error('No VM storage');
        const p = parseAsset(md5ext)||{ext:'svg', assetId:''};
        const type = (p.ext==='svg') ? storage.AssetType.ImageVector : storage.AssetType.ImageBitmap;
        storage.createAsset(type, p.ext, new Uint8Array(asset.arrayBuffer), p.assetId);

        t.sprite.costumes.push(cos);
        const idx = t.sprite.costumes.length - 1;

        if (vm.renderer) {
          if (isSVG && vm.renderer.createSVGSkin) {
            const text = await asset.blob.text();
            const skinId = vm.renderer.createSVGSkin(text);
            t.setCostume(idx);
            vm.renderer.updateDrawableProperties(t.drawableID, { skinId });
          } else if (!isSVG && vm.renderer.createBitmapSkin) {
            const bmp = await createImageBitmap(asset.blob);
            const skinId = vm.renderer.createBitmapSkin(bmp, 1);
            t.setCostume(idx);
            vm.renderer.updateDrawableProperties(t.drawableID, { skinId });
          } else {
            t.setCostume(idx);
          }
        } else {
          t.setCostume(idx);
        }

        try { vm.runtime.emit('PROJECT_CHANGED'); } catch(_){}
        log('[costume] success via manual injection (index '+idx+')');
      } catch(e){ throw new Error('Costume manual injection failed: '+(e&&e.message||e)); }
    }

    async function addSoundToSelectedSmart(name, md5ext){
      const vm = window.vm, GUI = window.GUI;
      if (!vm) throw new Error('vm missing');
      const t = (vm.runtime && vm.runtime.getEditingTarget && vm.runtime.getEditingTarget()) || (vm.runtime && vm.runtime.getTargetForStage && vm.runtime.getTargetForStage());
      if (!t) throw new Error('No editing target');

      const asset = await fetchAsset(md5ext);
      const snd = soundObj(name, md5ext);

      if (GUI && typeof GUI.handleSoundUpload === 'function'){
        try { log('[sound] GUI.handleSoundUpload'); await GUI.handleSoundUpload(asset.blob, t.id);
          log('[sound] success via GUI.handleSoundUpload'); return;
        } catch(e){ warn('[sound] GUI.handleSoundUpload failed: ' + (e&&e.message||e)); }
      }

      if (typeof vm.addSound === 'function'){
        try { await vm.addSound(md5ext, snd, t.id); log('[sound] success via vm.addSound'); return; }
        catch(e){ warn('[sound] vm.addSound failed: ' + (e&&e.message||e)); }
      } else { log('[sound] vm.addSound not available'); }

      throw new Error('No sound upload API available in this build; use GUI upload dialog');
    }

    const btnBackdropSky = document.getElementById('btn-add-sky-backdrop');
    const btnBackdropAsk = document.getElementById('btn-add-backdrop-prompt');
    const btnCostumeAsk  = document.getElementById('btn-add-costume-prompt');
    const btnSoundAsk    = document.getElementById('btn-add-sound-prompt');

    if (btnBackdropSky) btnBackdropSky.onclick = async ()=>{
      try { await addBackdropSmart('Blue Sky', 'e7c147730f19d284bcd7b3f00af19bb6.svg'); }
      catch(e){ warn('[tools] add sky failed: ' + (e&&e.message||e)); }
    };
    if (btnBackdropAsk) btnBackdropAsk.onclick = async ()=>{
      const md5ext = prompt('Backdrop md5.ext (svg/png):'); if (!md5ext) return;
      const name = prompt('Backdrop name:', 'Backdrop '+md5ext.slice(0,6)) || 'Backdrop';
      try { await addBackdropSmart(name, md5ext.trim()); }
      catch(e){ warn('[tools] add backdrop failed: ' + (e&&e.message||e)); }
    };
    if (btnCostumeAsk) btnCostumeAsk.onclick = async ()=>{
      const md5ext = prompt('Costume md5.ext (svg/png):'); if (!md5ext) return;
      const name = prompt('Costume name:', 'Costume '+md5ext.slice(0,6)) || 'Costume';
      try { await addCostumeToSelectedSmart(name, md5ext.trim()); }
      catch(e){ warn('[tools] add costume failed: ' + (e&&e.message||e)); }
    };
    if (btnSoundAsk) btnSoundAsk.onclick = async ()=>{
      const md5ext = prompt('Sound md5.ext (wav/mp3):'); if (!md5ext) return;
      const name = prompt('Sound name:', 'Sound '+md5ext.slice(0,6)) || 'Sound';
      try { await addSoundToSelectedSmart(name, md5ext.trim()); }
      catch(e){ warn('[tools] add sound failed: ' + (e&&e.message||e)); }
    };
  })();
  </script>
</body>
</html>
